# 《Swift 进阶》阅读纪要

《[Swift 进阶](https://objccn.io/products/advanced-swift/)》是 objc.io 出的[系列书籍](https://objccn.io/products/)之一。

在此记录阅读笔记。

- [内建集合类型](#内建集合类型)
- [可选值](#可选值)
- [函数](#函数)
- [结构体和类](#结构体和类)
- [枚举](#枚举)
- [字符串](#字符串)
- [协议](#协议)
- [错误处理](#错误处理)
- [编码和解码](#编码和解码)

## 内建集合类型

> Swift 标准库中的所有集合类型都使用了“写时复制”这一技术，它能够保证只在必要的时候对数据进行复制。

> 从内存安全的角度上说，下标操作是完全安全的，标准库中的集合总是会执行边界检查，并禁止那些越界索引对内存的访问。

> **官方标准库中的 `map` 版本没有指定它是否会按顺序来处理序列**，不过看起来现在这么做是安全的。

> **在 `forEach` 中的 `return` 并不能让外部函数返回，它仅仅只是让闭包本身返回。**

> 需要谨记的是切片和它背后的数组是使用相同的索引来引用元素的。因此，切片索引不需要从零开始。如果你操作切片的话，我们建议你总是基于 `startIndex` 和 `endIndex` 属性做索引计算。

> Dictionary 有一个 `merge(_:uniquingKeysWith:)`，它接受两个参数，第一个是要进行合并的键值对，第二个是定义如何合并相同键的两个值的函数。

> 标准库中所有的基本数据类型都是遵守 Hashable 协议的，它们包括字符串，整数，浮点数以及布尔值。另外，像是数组，集合和可选值这些类型，如果它们的元素都是可哈希的，那么它们自动成为可哈希的。

> 对于结构体和枚举，只要它们是由可哈希的类型组成，那么 Swift 就可以帮我们自动合成 Hashable 协议所需要的实现。如果一个结构体的所有存储属性都是可哈希的，那么我们不用手动实现 Hashable 协议，结构体就已经实现这个协议了。类似的，只要枚举包含可哈希的关联值，那么就可以自动实现这个协议；对于那些没有关联值的枚举，甚至都不用显式声明要实现 Hashable 协议。

> 标准库的通用哈希函数使用一个随机种子作为其输入之一。也就是说，字符串 "abc" 的哈希值在每次程序执行时都会是不同的。随机种子是一种用来防止有针对性的哈希洪泛式拒绝服务攻击的安全措施。因为字典和集合是按照存储在哈希表中的顺序来迭代它们的元素，并且由于这个顺序是由哈希值决定的，所以这意味着相同的代码在每次执行时会产生不同的迭代顺序。如果你需要哈希值每次都一样，例如为了测试，那么可以通过设置环境变量 `SWIFT_DETERMINISTIC_HASHING=1` 来禁用随机种子，但是你不应该在正式环境中这么做。

> 当你使用不具有值语义的类型 (比如可变的对象) 作为字典的键时，需要特别小心。如果你在将一个对象用作字典键后，改变了它的内容，它的哈希值和/或相等特性往往也会发生改变。这时候你将无法再在字典中找到它。这时字典会在错误的位置存储对象，这将导致字典内部存储的错误。对于值类型来说，因为字典中的键不会和复制的值共用存储，因此它也不会被从外部改变，所以不存在这个的问题。

> `Set` 和 `OptionSet` 是标准库中唯一实现了 `SetAlgebra` 的类型，但是这个协议在 Foundation 中还被另外两个很有意思的类型实现了：那就是 `IndexSet` 和 `CharacterSet`。

> `IndexSet` 表示了一个由正整数组成的集合。当然，你可以用 `Set<Int>` 来做这件事，但是 `IndexSet` 更加高效，因为它内部使用了一组范围列表进行实现。打个比方，现在你有一个含有 1000 个元素的 table view，你想要一个集合来管理已经被用户选中的元素的索引。使用 `Set<Int>` 的话，根据选中的个数不同，最多可能会要存储 1000 个元素。**而 `IndexSet` 不太一样，它会存储连续的范围，也就是说，在选取前 500 行的情况下，`IndexSet` 里其实只存储了选择的首位和末位两个整数值**。

> `CharacterSet` 是一个高效的存储 Unicode 编码点 (`code point`) 的集合。和 `IndexSet` 有所不同，`CharacterSet` 并不是一个集合类型。

> 只有半开范围能表达空间隔 (也就是下界和上界相等的情况，比如 `5..<5`)。

## 可选值

> 一个返回 `Never` 的函数用于通知编译器：它绝对不会返回。有两类常见的函数会这么做：一种是像 `fatalError` 那样表示程序失败的函数，另一种是像 `dispatchMain` 那样运行在整个程序生命周期的函数。编译器会使用这个信息来检查和确保控制流正确。举例来说，`guard `语句的 `else` 路径必须退出当前域或者调用一个不会返回的函数。

> `Never` 又被叫做**无人类型** (uninhabited type)。这种类型没有有效值，因此也不能够被构建。在 Swift 中，无人类型是通过一个不包含任意成员的 enum 实现的：`public enum Never { }`。

> `Void` 是空元组 (tuple) 的另一种写法：`public typealias Void = ()`。

> 正如 David Smith 所指出的，Swift 对“东西不存在”(`nil`)，“存在且为空”(`Void`) 以及 “不可能发生” (`Never`) 这几个概念进行了仔细的区分。

> 一个有点古怪 (但逻辑上合理) 的边界情况是你完全可以像下面这样直接给 Optional 赋值：
> ```swift
> var a: Int? = 5
> a? = 10
> a // Optional(10)
> var b: Int? = nil
> b? = 10
> b // nil
> ```
> 请注意 `a = 10` 和 `a? = 10` 的细微不同。前一种写法无条件地将一个新值赋给变量，而后一种写法只在 `a` 的值在赋值发生前不是 `nil` 的时候才生效。

> `a ?? b ?? c` 和 `(a ?? b) ?? c`。前者是合并操作的链接，而后者是先解包括号内的内容，然后再处理外层：
> ```swift
> let s1: String?? = nil // nil
> (s1 ?? "inner") ?? "outer" // inner
> let s2: String?? = .some(nil) // Optional(nil)
> (s2 ?? "inner") ?? "outer" // outer
> ```

> 可选值的 `map` 方法只会操作一个值，那就是该可选值中的那个可能存在的值。你可以把可选值当作一个包含零个或者一个值的集合，这样 `map` 要么在零个值的情况下不做处理，要么在有值的时候会对其进行转换。

> 当你在使用一个非可选值的时候，如果需要匹配成可选值类型，Swift 总是会将它“升级”为一个可选值。

> 其实，你可能会留一个注释来提醒为什么这里要使用强制解包。那为什么不把这个注释直接作为错误信息呢？这里我们加了一个 `!!` 操作符，它将强制解包和一个更具有描述性质的错误信息结合在一起，当程序意外退出时，这个信息也会被打印出来：
> ```swift
> infix operator !!
> func !! <T>(wrapped: T?, failureText: @autoclosure () -> String) -> T {
>   if let x = wrapped { return x }
>   fatalError(failureText())
> }
> ```
> 现在你可以写出更能描述问题的错误信息了，它还包括了你期望的被解包的值：
> ```swift
> let s = "foo"
> let i = Int(s) !! "Expecting integer, got \"\(s)\""
> ```

> ```swift
> infix operator !?
> func !?<T: ExpressibleByIntegerLiteral>
>     (wrapped: T?, failureText: @autoclosure () -> String) -> T
> {
>   assert(wrapped != nil, failureText())
>   return wrapped ?? 0
> }
> ```

## 函数

> Swift 只允许在函数声明中包含标签，这些标签不是函数类型的一部分。

> 一个函数和它所捕获的变量环境组合起来被称为闭包。

> 如果一个函数除了闭包表达式外没有别的参数，那么调用的时候在方法名后面的圆括号也可以一并省略。

> 一个 `inout` 参数持有一个传递给函数的值，函数可以改变这个值，然后从函数中传出并替换掉原来的值。

> `lazy` 关键字不会进行任何线程同步。

> Swift 提供了一个 `withoutActuallyEscaping` 函数来作为一种“安全出口”。这个函数允许你对一个接受逃逸闭包的函数，传入一个非逃逸的闭包。

## 结构体和类

> 要理解在属性和变量上用 `let` 和 `var` 的所有不同组合的关键是要记住两点：
> - 类型为类的变量的值，是一个指向实例的引用；而类型为结构体的变量的值，是结构体实例本身。
> - 修改一个结构体的属性，即使修改的是多层的嵌套属性，都等同于给变量赋值一个全新的结构体实例。

> 就像对待普通的参数一样，Swift 还是会复制传入的 `inout` 参数，但当函数返回时，会用这些参数的值覆盖原来的值。也就是说，即使在函数中对一个 `inout` 参数做多次修改，但对调用者来说只会注意到一次修改的发生，也就是在用新的值覆盖原有值的时候。同理，即使函数完全没有对 `inout` 参数做任何的修改，调用者也还是会注意到一次修改 (`willSet` 和 `didSet` 这两个观察者方法都会被调用)。

> 当对象没有任何强引用的时候，会释放所有资源 (例如，对其他对象的引用)。然而，只要对象还有 unowned 引用存在，其自身所占用的内存就不会被回收。这块内存会被标记为无效，有时也称作僵尸内存 (zombie memory)。被标记为僵尸内存之后，只要我们尝试访问这个 unowned 引用，就会发生一个运行时错误。
> 但我们也可以通过 `unowned(unsafe)` 来绕过这个保护机制，当访问一个被标记为 `unowned(unsafe)` 的无效引用时，行为是未定义的。

> 捕获列表（capture list）可以做的不仅仅只是将变量标记为 `weak` 或 `unowned`。比如，如果我们想有一个指向 window 的弱引用变量的话，可以直接在捕获列表中初始化这样一个变量；或者甚至可以在其中定义完全不相关的变量。

> 如果你可以保证，非强引用的对象与持有这个引用的对象的生命周期是一样的，甚至于更长的话，`unowned` 引用通常是更方便的。因为它的类型不需要是可选值，并可以被声明为 `let`，而弱引用则必须是用 `var` 声明的可选值。
> 相比弱引用，`unowned` 引用的开销也小一点，通过它访问属性或调用方法的速度会快一点点。

> 对于长度最多只有15个 UTF-8 编码单元 (code unit) 的短字符串，Swift 实现了一种优化来避免为其分配一个缓冲区。

> 我们可以使用 `isKnownUniquelyReferenced` 函数来检查一个引用类型的实例是否只有一个所有者。 如果你把一个 Swift 的类实例传递给此函数，并且这个实例没有其他强引用的话，这个函数就返回 `true`，反之，如果有其他强引用存在，此函数返回 `false`。
> 虽然这个函数是线程安全的，但是，你必须保证传入的变量不会被另外一个线程所访问，这个限制不单单只是针对 `isKnownUniquelyReferenced`，它适用于所有的 `inout` 参数。换言之，`isKnownUniquelyReferenced` 不能防止竞争条件 (race condition)。

## 枚举

> 一个类型，是它的实例所能表示的所有可能的值的集合，值也被称为居民 (inhabitant)。
> `Bool` 有两个居民，`false` 和 `true`。`UInt8` 有 28，也就是 256 个居民。`Int64` 有 2^64，也就是大约 1.84 千京 (千京等于 1019) 个居民。像是字符串这种类型，至少在填满内存之前，会有无穷多的居民，因为你总是可以通过追加一个字符来创建另一个字符串。

> 通常来说，一个元组 (或者结构体，类) 的居民数量，等于其成员的居民数量的乘积。因此，结构体，类和元组也被称为**乘积类型 (Product Types)**。
> 一般而言，一个枚举的居民数量，等于它所有成员的居民数量的总和。这也是为什么称枚举为 **总和类型（Sum Types）** 的原因。

> 在 `switch` 语句中，`case _ `是等同于 `default` 关键字的：两者都匹配任意值，并且把它们作为最后一个分支才是合理的。

> 为了忽略一个关联值，可以在子模式中使用下划线，或删除整个子模式来达到目的，例如，`.success(_)` 和 `.success` 就是等价的。

> **一个 `switch` 语句必须是完备的**，也就是说，它的分支必须覆盖所有可能的输入值。编译器也会强制执行这个完备性。
> 因此我们建议你**尽可能避免在 `switch` 语句中使用 `default` 分支**。

> 一个系统可以存在的状态集合也称为其状态空间。

> 对于没有关联值的枚举，编译器会自动生成实现 `CaseIterable` 的代码；
> `CaseIterable` 协议没有规定 `allCases` 返回的集合中的值的特定顺序，但 `CaseIterable` 的文档中则保证集合中的值的顺序是和它们在声明时的顺序所一致的。

> `allCases` 的返回类型不必一定是数组 - 它可以是任何一个实现了 `Collection` 的类型。

> **不要让你所不拥有的类型去实现你不拥有的协议。**

> 可能会在未来添加新成员的枚举，称之为非固定。
> 在一个模块中 `switch` 另一个模块中的非固定枚举的话，必须始终包含一个 `default` 子句，以便能够处理将来会发生的这种情况。
> **尽量避免使用嵌套 switch 语句**。你可以使用元组一次性匹配多个值。

> **利用明确初始化检查 (definite initialization check)。**
> 编译器会在首次使用一个变量之前去验证这个变量是否已完全初始化了 - 如果我们在一条或多条代码路径中忘记初始化的话，编译器会产生一个错误。
> **避免用 `none` 或 `some` 来命名成员。**
> **对那些用保留的关键字来命名的成员使用反引号 (backtick)。**
> 可以像工厂方法一样使用成员。如果一个成员拥有关联值的话，这个枚举值就单独地形成了一个签名为 `(AssocValue) -> Enum` 的函数。
> **不要使用关联值来模拟存储属性。请改用结构体。**

> 这是一个通用模式：当你发现一个枚举中每个成员的关联值都有一部分是相同的，请考虑把这个枚举封装到一个结构体中，并把公共部分提取出来。这会改变结果类型的样子，但不会改变其基本性质。这和在数学等式中提取公因子是一样的：`a x b + a x c = a x (b + c)`。这种与代数的对应关系也解释了为什么把**总和类型和乘积类型总称为“代数数据类型”**。

> **把空枚举作为命名空间**。除了由模块形成的隐式命名空间之外，Swift 没有内置的命名空间。但我们可以用枚举来“模拟”命名空间。由于类型定义是可以嵌套的，因此外部类型可以充当其包含的所有声明的命名空间。

## 字符串

> 一个 Unicode 字符，也叫做扩展字位簇 (extended grapheme cluster)，由一个或多个 Unicode 标量 (Unicode scalar) 组成。
> 一个 Unicode 标量可以被编码成一个或多个编码单元 (code units)。
> Unicode 中最基础的原件叫做编码点 (code point)：它是一个位于 Unicode 编码空间 (从 0 到 0x10FFFF，也就是十进制的 1,114,111) 中的整数。
> Unicode 标量和刚才提到的编码点，在绝大多数情况下，是同一个东西。或者说，除了编码点中 0xD800 - 0xDFFF 之外的值，都可以叫做 Unicode 标量。而 0xD800 - 0xDFFF 这 2048 个值则叫做 代理编码点 (surrogate code points)，它们在 UTF-16 编码中用于表示那些值大于 65535 的字符。
> 提及到“字符”这个概念，Unicode 仍就是一个可变宽度的格式。因为用户在屏幕上看到的“单个字符”，可能是由多个 Unicode 标量组合起来的。对于这种用户感知到的“单个字符”，Unicode 中有一个术语，叫做 (扩展) 字位簇，对应的英文叫做 (extended) grapheme cluster。

> 如果你真要按照标准等价的方式进行比较两个 `NSString`，就得使用 `NSString.compare(_:)` 方法。

> `CR+LF` 字符表示回车 (carriage return) 和换行 (line feed) 的组合

> Unicode 的解决方案是把这种复杂的颜文字表示成一个简单颜文字的序列，序列中的颜文字则通过一个标量值为 U+200D 的不可见零宽连接字符 (zero-width joiner，ZWJ) 连接。因此，家庭颜文字 👨‍👩‍👧‍👦 是由男人 👨 + ZWJ + 女人 👩 + ZWJ + 女孩 👧 + ZWJ + 男孩 👦 构成的。ZWJ 的存在，是对操作系统的提示，表明如果可能的话，把 ZWJ 连接的字符当成一个字形符号 (glyph) 处理。
> 在 2016 年引入的代表职业的颜文字也是 ZWJ 序列。比如，一个女性消防员 👩‍🚒 是女人 👩 + ZWJ + 消防车 🚒, 的组合。而男性医护工作者 👨‍⚕️ 则是男人 👨 + ZWJ + 医疗之神阿斯克勒庇俄斯的权杖 ⚕ 的序列。

> `Substring` 和 `ArraySlice` 很相似：它是一个以原始字符串内容为基础，用不同起始和结束位置标记的视图。**子字符串和原字符串共享文本存储**。

> utf8 集合不包含字符串尾部的 null 字节。如果你需要用 null 表示结尾的话，可以使用 `String` 的 `withCString` 方法或者 `utf8CString` 属性。

> Swift 字符串在内存中的原生编码是 UTF-8，而 NSString 是 UTF-16。

> Foundation 中用来显示带有格式的富文本的 `NSAttributedString` 就是一例。要在 Swift 中成功使用属性字符串，你必须注意下面这些：
> - 有两个类，`NSAttributedString` 对应不可变字符串，`NSMutableAttributedString` 对应可变字符串。和 Swift 标准库中遵守值语义的集合不同，它们都遵守引用语义。
> - 虽然 `NSAttributedString` 的 API 原来接受的是 `NSString`，但是它现在接受一个 `Swift.String`。不过整个 API 的基础还是 `NSString` 的 UTF-16 编码单元集合的概念。频繁地在 `String` 和 `NSString` 之间发生桥接可能会带来意外的性能开销。

> 但如果你没有实现 `CustomDebugStringConvertible`，`String(reflecting:)` 就会选择使用 `CustomStringConvertible` 提供的结果，反之也是。如果你的类型没有实现`CustomStringConvertible`，`String(describing:)` 会选择使用 `CustomDebugStringConvertible` 提供的结果。

> `Array` 总是会打印它包含的元素的调试版信息。

## 协议

> 带有默认实现的协议方法在 Swift 社区中有时也叫做定制点 (customization point)。

> 当我们把协议当作具体类型使用的时候，编译器会为协议创建一个包装类型，叫做**存在体 (existential)**。`let context: DrawingContext` 这种写法本质上就是类似 `let context: Any<DrawingContext>` 这种写法的语法糖。尽管这种语法并不存在，编译器会创建一个 (32 字节的) `Any` 盒子，并在其中为类型实现的每个协议添加一个 8 字节的协议目击者。
> 为协议创建的这个盒子也叫做 **存在体容器 (existential container)**。这是编译器必须要做的事情，因为它需要在编译期确认类型的大小。不同的类型自身大小有差异 (例如：所有的类都是一个指针的大小，而结构体和枚举的大小则依赖它们的实际内容)，这些类型实现了一个协议的时候，把协议包装在存在体容器中可以让类型的尺寸保持固定，编译器也就能确定对象的内存布局了。

## 错误处理

> Swift 的异常机制并不会像很多语言那样带来额外的运行时开销。编译器会认为 `throw` 是一个普通的返回，这样一来，普通的代码路径和异常的代码路径速度都会很快。

> 我们也可以把一个结构体或者类作为错误类型来使用；任何遵守 Error 协议的类型都可以被函数作为错误抛出。而且由于 `Error` 协议中其实并没有任何要求，所以任何类型都可以声明遵守它，而并不需要添加任何额外的实现。
> 为了快速测试某些代码，或者编写一些简单原型的时候，我们发现，让 `String` 实现 `Error` 有时会很有帮助。只需要一行代码就可以搞定了：`extension String: Error {}`。这样，就可以直接把表达错误消息的字符串作为可抛出的错误值使用，例如：`throw "File not found"`。在生产环境的代码里，我们并不推荐如此，因为**让一个不属于你的类型实现某个协议并不是值得推荐的做法**。

> Swift 原生的错误处理机制使用了**无类型错误 (untyped errors)**。我们只能用 `throws` 声明函数会抛出错误，但无法指定它究竟会抛出哪些具体的错误。因此，为了从语言层面确保所有错误都可以被处理，编译器才总是要求我们编写一个 `catchall` 语句。在错误处理系统中使用无类型错误是 Swift 核心团队刻意为之的。原因是在大部分情况下，巨细无遗的错误处理是不现实也没必要的。通常，你可能只关心一两个特定的错误情况，然后给其它错误在 `catchall` 语句中提供一个通用的处理方法就好了。

> `Result`，则属于**具体类型错误 (typed errors)**。`Result` 带有两个泛型参数，`Success` 和 `Failure`，而后者指定了错误的具体类型。
> `Result` 实际上是一个同时支持两种错误处理范式的混合体。如果你不希望指定具体的错误类型，就用 `Result<..., Error>` 作为返回值就行了。

> 错误链
> - throw 链
>   - 我们不需要使用嵌套的 `if` 语句或者类似的结构来保证代码运行，只要简单地将这些函数调用放到一个 `do/catch` 代码块中 (或者封装到一个被标记为 `throws` 的函数中) 就好了。当遇到第一个错误时，调用链将结束，代码将被切换到 `catch` 块中，或者传递到上层调用者去。
> - Result 链
>   - 我们必须用 `mapError` (这是 `Result` 提供的方法) 对错误类型再进行一次转换。
>   - `Result.flatMap` 方法封装了这种根据 `Result` 结果决定是要继续向下个环节传递成功值，还是由于失败必须退出调用链的模式。

> 和 `finally` 不同的是，`defer` 不需要前置的 `try` 或 `do` 代码块，你可以把它部署到代码中的任何地方。

> 如果相同的作用域中有多个 `defer` 代码块，它们将按照定义的顺序逆序执行。

> 一个 `defer` 代码块会在程序离开 `defer` 定义的作用域时被执行。甚至 `return` 语句的评估都会在同作用域的 `defer` 被执行之前完成。

> Swift 通过 `rethrows` 关键字提供了一个更好的方案。用 `rethrows` 标记一个函数就相当于告诉编译器：这个函数只有它的参数抛出错误的时候，它才会抛出错误。

> 将错误桥接到 Objective-C
> ```
> // Objective-C 版本的 `contents(ofFile:)` 写出来可能是这样的：
> - (NSString *)contentsOfFile(NSString *)filename error:(NSError **)error;
> 
> // Swift
> func contents(ofFile filename: String) throws -> String
> ```
> 
> Swift 会自动把遵循这个规则 (译注：这个规则指的是接受 `NSError **` 作为参数) 的方法转换为 `throws` 语法的版本。因为不再需要参数传递错误了，它会从声明中删除。
> 签名的转换过程除了会删除 `NSError **` 类型的参数之外，对于那些返回 `BOOL` 来表示操作成功与否的函数，例如 `createDirectoryAtPath`，转换到 Swift 之后也会变成一个 `throws` 函数，也就不再需要使用 `BOOL` 表示调用结果了，因此，`BOOL` 会变成 Void。

> 如果你把一个 Swift 错误传递给 Objective-C 的方法，类似地，它将被桥接为 `NSError`。因为所有的 `NSError` 对象都必须有一个 `domain` 字符串和一个整数的错误代码 `code`，运行时将在必要的时候提供默认值，它会使用类型名作为 `domain`，使用从 0 开始的枚举的序号作为错误代码。如果有需要，你也可以让你的错误类型遵守 `CustomNSError` 协议来提供自定义的值。

> 你还可以实现下面这两个协议，来让你的错误拥有更有意义的描述，并且更好地遵循 Cocoa 的习惯：
> - `LocalizedError` — 提供一个本地化的信息，来表示错误为什么发生 (failureReason)，从错误中恢复的提示 (recoverySuggestion) 以及额外的帮助文本 (helpAnchor)。
> - `RecoverableError` — 描述一个用户可以恢复的错误，展示一个或多个 recoveryOptions，并在用户要求的时候执行恢复。这多用于使用了 AppKit 的 macOS 应用。
> 就算没有实现 `LocalizedError` 协议，所有实现了 `Error` 的类型也会有一个可以重写的 `localizedDescription` 属性。

> 实现 `Error` 的那些类型也可以定义自己的 `localizedDescription`。不过，因为这并不是 `Error` 协议所要求的，这个属性也不支持动态派发。除非你也遵守了 `LocalizedError`，否则在 Objective-C 的 API 或者 `Error` 的存在体容器 (existential container) 里，你将不能使用这个自定义的 `localizedDescription`。当编写 Cocoa 应用的时候，你应该总是让传递给 Cocoa API 的错误类型实现 `LocalizedError` 协议。

## 编码和解码

> 实际上，`JSONEncoder` 甚至都没有实现 `Encoder` 协议。相反，它只是一个叫做 `_JSONEncoder` 的私有类的封装，这个私有类实现了 `Encoder` 协议，并且进行实际的编码工作。之所以这样做，是因为顶层编码器 (译注：这里指 `JSONEncoder`) 应该提供的 API (这个 API 通常只用于启动编码过程)，和在编码过程中传递给可编码类型的 `Encoder` 对象 (译注：这里指 `_JSONEncoder`) 是截然不同的。将这些任务清晰地分开，意味着在任意给定的情景下，使用编码器的一方只能访问到适当的 API。

> 容器有三种类型：
> - **键容器 (Keyed Container)** 用于编码键值对。可以把键容器想像为一个特殊的字典，这是到目前为止，应用最普遍的容器。
> 键容器内部使用的键是强类型的，这为我们提供了类型安全和自动补全的特性。编码器最终会在写入目标格式 (比如 JSON) 时，将键转换为字符串 (或者数字)，不过这对开发者来说是隐藏的。修改编码后的键名是最简单的一种自定义编码方式的操作，我们将会在下面看到一些相关的例子。
> - **无键容器 (Unkeyed Container)** 用于编码一系列值，但不需要对应的键，可以将它想像成保存编码结果的数组。因为没有对应的键来确定某个值，所以对无键容器中的值进行解码的时候，需要遵守和编码时同样的顺序
> - **单值容器**对单一值进行编码。你可以用它来处理只由单个属性定义的那些类型。例如：`Int` 这样的原始类型，或以原始类型实现了 `RawRepresentable` 协议的枚举。

> 所有键都必须可以用字符串的形式表示，另外，一个键类型也可以提供和整数互相转换的能力。如果使用整数更高效，编码器会选择整数形式的键。但它们也可以完全忽略掉这个特性而坚持使用字符串键，而 `JSONEncoder` 就是这么做的。因此，编译器合成的默认代码也只包含了字符串键。

> `Range`，它使用无键容器来编码上下边界。

> 和编码器类似，解码器也管理一棵由解码容器 (decoding containers) 构成的树，树中所包含的容器我们已经很熟悉了，它们还是键容器，无键容器，以及单值容器。

> Swift 只在两种情况下会自动合成协议实现的代码，分别是直接添加在类型定义上的协议，以及定义在同一个文件的类型扩展上的协议。

> “实际上我会更进一步，并且建议在当你想要扩展别人的类型，使其满足 `Encodable` 或 `Decodable` 时，你几乎总是应该考虑写一个结构体把它封装起来，除非你有理由能够确信这个类型自己绝对不会去遵循这些协议。” —— Apple 的工程师 Itai Ferber

> 另一种方案是使用嵌套容器来编码经纬度。`KeyedDecodingContainer` 有一个叫做 `nestedContainer(keyedBy:forKey:)` 的方法，它可以在 `forKey` 指定的键上，新建一个嵌套的键容器 (译注：想象一下，原本这个键对应的应该是在原始容器中保存的编码结果)，这个嵌套键容器使用 `keyedBy` 参数指定的另一套编码键。
