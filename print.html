<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kilig 的第二大脑</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Introduction.html"><strong aria-hidden="true">1.</strong> 首页</a></li><li class="chapter-item expanded "><a href="meta/meta.html"><strong aria-hidden="true">2.</strong> 知识体系单元</a></li><li class="chapter-item expanded "><a href="macOS/macOS.html"><strong aria-hidden="true">3.</strong> macOS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macOS/cli/cli.html"><strong aria-hidden="true">3.1.</strong> 命令行</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macOS/cli/ohmyzsh.html"><strong aria-hidden="true">3.1.1.</strong> Oh My Zsh</a></li><li class="chapter-item expanded "><a href="macOS/cli/homebrew.html"><strong aria-hidden="true">3.1.2.</strong> Homebrew</a></li><li class="chapter-item expanded "><a href="macOS/cli/rbenv.html"><strong aria-hidden="true">3.1.3.</strong> rbenv</a></li></ol></li><li class="chapter-item expanded "><a href="macOS/apps.html"><strong aria-hidden="true">3.2.</strong> macOS 应用</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 计算机科学</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ProgrammingLanguages/ProgrammingLanguages.html"><strong aria-hidden="true">4.1.</strong> 编程语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ProgrammingLanguages/Swift/Swift.html"><strong aria-hidden="true">4.1.1.</strong> Swift</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ProgrammingLanguages/Swift/AdvancedSwift.html"><strong aria-hidden="true">4.1.1.1.</strong> Swift 进阶</a></li></ol></li><li class="chapter-item expanded "><a href="ProgrammingLanguages/OC/OC.html"><strong aria-hidden="true">4.1.2.</strong> Objective-C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ProgrammingLanguages/OC/OCNote.html"><strong aria-hidden="true">4.1.2.1.</strong> Objective-C 底层学习笔记</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="Design/Design.html"><strong aria-hidden="true">5.</strong> 设计</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Design/Sketch.html"><strong aria-hidden="true">5.1.</strong> Sketch</a></li><li class="chapter-item expanded "><a href="Design/Figma.html"><strong aria-hidden="true">5.2.</strong> Figma</a></li></ol></li><li class="chapter-item expanded "><a href="Stories/Stories.html"><strong aria-hidden="true">6.</strong> 故事</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kilig 的第二大脑</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/KiligWYu/Knowledge-Track" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="使用说明"><a class="header" href="#使用说明">使用说明</a></h1>
<p>Hi, there. 欢迎来到 Kilig 的第二大脑，藏在这儿都被你发现了。</p>
<p>这里会结构化地记录我希望记住的一些知识性的内容，不定时更新。</p>
<ul>
<li>👈 通过侧边栏的层级导航菜单可以快速了解大概的知识体系</li>
<li>按下「S」键可快速搜索</li>
</ul>
<h2 id="关于我"><a class="header" href="#关于我">关于我</a></h2>
<p>若有兴趣了解和认识我，这儿有个「<a href="https://KiligWYu.com/">年更博客</a>」。</p>
<hr />
<p>Inspired by <a href="https://binlogo.github.io/Knowledge-Track/Introduction.html">棒棒杉的第二大脑</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>希望这里将会是我真正意义上的第二大脑。</p>
<blockquote>
<p>弱水三千，取一瓢饮。</p>
</blockquote>
<h2 id="笔记流程"><a class="header" href="#笔记流程">笔记流程</a></h2>
<blockquote>
<p>Input -&gt; Process -&gt; Output</p>
</blockquote>
<p><a href="https://bear.app">Bear</a> 输入，<a href="https://code.visualstudio.com">VSCode</a> 加工，<a href="https://github.com/KiligWYu/Knowledge-Track">GitHub</a> 输出。</p>
<h2 id="内容结构"><a class="header" href="#内容结构">内容结构</a></h2>
<ol>
<li>标题</li>
<li>描述</li>
<li>相关内容</li>
<li>记录正文</li>
<li>链接</li>
</ol>
<h2 id="搭建记录与发布"><a class="header" href="#搭建记录与发布">搭建、记录与发布</a></h2>
<ul>
<li><a href="https://bear.app">Bear</a> + <a href="https://code.visualstudio.com">VSCode</a> 书写 ✍️</li>
<li><a href="https://github.com/rust-lang/mdBook">mdBook</a> 生成 🧰</li>
<li><a href="https://pages.github.com">GitHub Pages</a> 发布 🌏</li>
</ul>
<blockquote>
<p>采用<strong>免费的</strong> <a href="https://github.com/features/actions">GitHub Actions</a> 自动化部署。</p>
</blockquote>
<h2 id="其他大脑传送带"><a class="header" href="#其他大脑传送带">其他大脑传送带</a></h2>
<ul>
<li><a href="https://binlogo.github.io/Knowledge-Track/Introduction.html">棒棒杉的第二大脑</a> - 灵感来源</li>
<li><a href="https://wiki.nikitavoloboev.xyz">Everything I know by Nikita Voloboev</a></li>
<li><a href="https://davidseah.gitbook.io/davidseah">David Seah</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macos"><a class="header" href="#macos">macOS</a></h1>
<p>记录 macOS 应用与习惯的环境配置。</p>
<h2 id="前置网络环境配置"><a class="header" href="#前置网络环境配置">前置网络环境配置</a></h2>
<ul>
<li><a href="https://nssurge.com">Surge</a></li>
<li><a href="https://github.com/yichengchen/clashX">ClashX</a></li>
<li><a href="https://github.com/shadowsocks/ShadowsocksX-NG">ShadowsocksX-NG</a></li>
</ul>
<h2 id="开发环境配置"><a class="header" href="#开发环境配置">开发环境配置</a></h2>
<ul>
<li><a href="macOS/./cli/ohmyzsh.html">Oh My Zsh</a></li>
</ul>
<pre><code class="language-sh">sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;
</code></pre>
<ul>
<li><a href="macOS/./cli/homebrew.html">Homebrew</a></li>
</ul>
<pre><code class="language-sh">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;
</code></pre>
<ul>
<li><a href="macOS/./cli/rbenv.html">rbenv</a> - ruby 环境管理工具</li>
</ul>
<pre><code class="language-sh">brew install rbenv ruby-build
</code></pre>
<ul>
<li><a href="https://cocoapods.org/">CocoaPods</a></li>
</ul>
<pre><code class="language-sh">sudo gem install cocoapods
pod setup
</code></pre>
<p>对于苹果芯片的电脑，需要在命令前加上 <code>arch -x86_64</code>。e.g. <code>arch -x86_64 pod setup</code>.</p>
<h2 id="更多-cli"><a class="header" href="#更多-cli">更多 CLI</a></h2>
<ul>
<li><a href="https://github.com/websperts/tinypng-cli">TinyPNG CLI</a></li>
</ul>
<pre><code class="language-sh">npm install -g tinypng-cli
</code></pre>
<blockquote>
<p><a href="https://tinypng.com/">TinyPNG</a> 是一个提供 PNG 和 JPEG 格式图片无损压缩的网站，压缩率高，并且基本不会丢失图片细节。TinyPNG CLI 则是利用其开发者接口制作的命令行工具。</p>
<p>使用 npm 安装 CLI 工具后，进入 TinyPNG 的 <a href="https://tinypng.com/developers">开发者界面</a> 申请 API Key，在系统的用户目录创建名为「.tinypng」的文件并将获得的 Key 写入此文件。接着，我们就能在终端中使用 tinypng [filepath] 来压缩图片了，压缩后的图片将直接替换原图片。</p>
<p>用户每个月能免费压缩 500 张图片，每张图片不能超过 5 MB。</p>
</blockquote>
<ul>
<li><a href="https://github.com/PicGo/PicGo-Core">PicGo-Core</a></li>
</ul>
<pre><code class="language-sh">npm install -g picgo
</code></pre>
<p>插件:</p>
<pre><code class="language-sh">picgo install autocopy rename-file
</code></pre>
<h2 id="链接"><a class="header" href="#链接">链接</a></h2>
<ul>
<li><a href="https://github.com/herrbischoff/awesome-macos-command-line">Awesome macOS Command Line</a></li>
<li><a href="https://sspai.com/post/65934">换一种姿势使用网页服务，这些命令行工具值得一试</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命令行"><a class="header" href="#命令行">命令行</a></h1>
<p>假装「黑客」一样行事直到不希望被发现。😜</p>
<h2 id="工具"><a class="header" href="#工具">工具</a></h2>
<ul>
<li><a href="https://github.com/sharkdp/bat"><code>bat</code></a> - A cat(1) clone with syntax highlighting and Git integration.</li>
</ul>
<h2 id="alias"><a class="header" href="#alias">Alias</a></h2>
<pre><code class="language-sh"># Proxy
alias sson='export https_proxy=http://127.0.0.1:6152;export http_proxy=http://127.0.0.1:6152;export all_proxy=socks5://127.0.0.1:6153'
alias ssoff='unset all_proxy'

export https_proxy=http://127.0.0.1:6152;export http_proxy=http://127.0.0.1:6152;export all_proxy=socks5://127.0.0.1:6153

# 更新 ClashX Country.mmdb
alias updateGeoIP='curl -o ~/.config/clash/Country.mmdb https://github.com/Hackl0us/GeoIP2-CN/raw/release/Country.mmdb'

# Show Connected Device's UDID
alias udid='system_profiler SPUSBDataType | sed -n -e '/iPad/,/Serial/p' -e '/iPhone/,/Serial/p''

#  Show External IP Address
alias ip='dig +short myip.opendns.com @resolver1.opendns.com'

# Hexo
alias cgd='hexo clean &amp;&amp; hexo g &amp;&amp; hexo d'
alias cgs='hexo clean &amp;&amp; hexo g &amp;&amp; hexo s'

# Alias the system vim to MacVim
alias vi=&quot;/Applications/MacVim.app/Contents/MacOS/Vim&quot;
alias vim=&quot;vi&quot;
alias mvim=&quot;vi -g&quot;

# Aria2
alias aria=&quot;~/OneDrive/Backups/aria2-trackers-update.sh&quot;

# ping
alias ping5='ping -c 5'

function ~() {
    cd ~
}

# switch between release and beta xcodes
function xcswitch() {
    RELEASE=&quot;Xcode.app&quot;
    BETA=&quot;Xcode-beta.app&quot;

    CURRENT=$(xcode-select -p)
    NEXT=&quot;&quot;

    if [[ &quot;$CURRENT&quot; =~ &quot;$RELEASE&quot; ]]
    then
        NEXT=&quot;$BETA&quot;
    else
        NEXT=&quot;$RELEASE&quot;
    fi

    sudo xcode-select -s &quot;/Applications/$NEXT&quot;
    echo &quot;Switched to $NEXT&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oh-my-zsh"><a class="header" href="#oh-my-zsh"><a href="https://ohmyz.sh/#install">Oh My Zsh</a></a></h1>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<pre><code class="language-sh">sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;
</code></pre>
<h2 id="主题"><a class="header" href="#主题">主题</a></h2>
<p><code>ZSH_THEME=&quot;af-magic&quot;</code> (inside <code>~/.zshrc</code>).</p>
<h2 id="zsh-autosuggestions-自动补全"><a class="header" href="#zsh-autosuggestions-自动补全"><a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a> 自动补全</a></h2>
<pre><code class="language-sh">brew install zsh-autosuggestions
</code></pre>
<p>Add the plugin to the list of plugins for Oh My Zsh to load (inside <code>~/.zshrc</code>):</p>
<pre><code class="language-sh">plugins=(zsh-autosuggestions)
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=&quot;fg=#ff00ff,bg=cyan,bold,underline&quot; # Suggestion Highlight Style
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="homebrew"><a class="header" href="#homebrew"><a href="https://brew.sh">Homebrew</a></a></h1>
<h2 id="安装-1"><a class="header" href="#安装-1">安装</a></h2>
<pre><code class="language-sh">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;
</code></pre>
<h2 id="常用命令"><a class="header" href="#常用命令">常用命令</a></h2>
<ul>
<li><code>brew search [TEXT|/REGEX/]</code></li>
<li><code>brew info [FORMULA...]</code></li>
<li><code>brew install FORMULA...</code></li>
<li><code>brew update</code></li>
<li><code>brew upgrade [FORMULA...]</code></li>
<li><code>brew uninstall FORMULA...</code></li>
<li><code>brew list [FORMULA...]</code></li>
<li><code>brew cleanup</code></li>
</ul>
<h2 id="formulae"><a class="header" href="#formulae">Formulae</a></h2>
<ul>
<li><a href="https://github.com/iawia002/annie">annie</a></li>
<li><a href="https://aria2.github.io/">aria2</a></li>
<li><a href="https://stedolan.github.io/jq/">jq</a></li>
<li><a href="https://github.com/mas-cli/mas">mas</a></li>
<li><a href="https://hasseg.org/trash/">trash</a></li>
<li><a href="https://github.com/xcodereleases/xcinfo">xcinfo</a></li>
<li><a href="http://mama.indstate.edu/users/ice/tree/">tree</a></li>
</ul>
<p><code>tree -N</code> 解决 <code>tree</code> 中文乱码。</p>
<blockquote>
<p>-N            Print non-printable characters as is.</p>
</blockquote>
<h2 id="casks"><a class="header" href="#casks">Casks</a></h2>
<ul>
<li><a href="https://github.com/tonsky/FiraCode">font-fira-code</a></li>
<li><a href="https://www.jetbrains.com/lp/mono">font-jetbrains-mono</a></li>
<li><a href="https://github.com/adobe-fonts/source-han-sans">font-source-han-sans</a></li>
<li><a href="https://github.com/adobe-fonts/source-han-serif">font-source-han-serif</a></li>
</ul>
<h2 id="其他"><a class="header" href="#其他">其他</a></h2>
<p>避免触发自动更新</p>
<pre><code class="language-sh">export HOMEBREW_NO_AUTO_UPDATE=1
</code></pre>
<h2 id="链接-1"><a class="header" href="#链接-1">链接</a></h2>
<ul>
<li><a href="https://sspai.com/post/65842">从零开始，编写一个 HomeBrew 缓存清理脚本</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rbenv---ruby-环境管理工具"><a class="header" href="#rbenv---ruby-环境管理工具"><a href="https://github.com/rbenv/rbenv">rbenv</a> - ruby 环境管理工具</a></h1>
<h2 id="安装-2"><a class="header" href="#安装-2">安装</a></h2>
<pre><code class="language-sh">brew install rbenv ruby-build
</code></pre>
<p><a href="https://github.com/sstephenson/rbenv">ruby-build</a> 用来编译安装 Ruby 源码，如果选择手动编译，可不使用这个工具。</p>
<h2 id="常用命令-1"><a class="header" href="#常用命令-1">常用命令</a></h2>
<ul>
<li><code>rbenv install --list</code> 查看可用的 ruby版本</li>
<li><code>rbenv install 3.0.1</code> 从列表中选择 3.0.1 进行安装</li>
<li><code>rbenv versions</code> 查看已经安装的所有 Ruby 版本</li>
<li><code>rbenv global 3.0.1</code> 设置全局版本</li>
<li><code>rbenv local 3.0.1</code> 设置本地版本</li>
<li><code>rbenv shell 3.0.1</code> 设置当前终端版本</li>
<li><code>rbenv global system</code> 使用系统 Ruby</li>
<li><code>rbenv rehash</code> 使用 rbenv 后，gem 还是按照原有的方式进行安装、升级，只是 gem 的安装路径是在 ~/.rbenv 文件夹中当前 Ruby 版本文件夹下。而且，安装带有可执行文件的 gem 后，需要执行一个特别的命令，告诉 rbenv 更新相应的映射关系，这个命令在安装新版本的 Ruby 后也需要执行</li>
</ul>
<p>rbenv 中的 Ruby 版本有三个不同的作用域：全局 (global)，本地 (local)，当前终端 (shell)，<strong>查找版本的优先级是 当前终端 &gt; 本地 &gt; 全局。</strong></p>
<h2 id="链接-2"><a class="header" href="#链接-2">链接</a></h2>
<ul>
<li><a href="https://gist.github.com/sandyxu/8aceec7e436a6ab9621f">使用 rbenv 安装和管理 Ruby 版本</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macos-应用"><a class="header" href="#macos-应用">macOS 应用</a></h1>
<p>记录日常使用与喜爱的 macOS 应用</p>
<ul>
<li><a href="https://adguard.com/zh_cn/adguard-mac/overview.html">AdGuard</a> - 广告拦截</li>
<li><a href="https://github.com/davidwernhart/AlDente">AlDente</a> - MBP 充电限制</li>
<li><a href="https://www.alfredapp.com">Alfred</a> - 快捷打开任意应用或工作流</li>
<li><a href="https://alt-tab-macos.netlify.app">AltTab</a> - 应用切换</li>
<li><a href="https://freemacsoft.net/appcleaner">AppCleaner</a> - 应用卸载</li>
<li><a href="https://apps.apple.com/us/app/id451732904">App Language Chooser</a> - 切换 App 语言</li>
<li><a href="https://apps.apple.com/us/app/id809625456">Asset Catalog Creator Pro</a> - App 多尺寸图标自动生成</li>
<li><a href="https://www.avtouchbar.com">AVTouchBar</a> - Touch Bar 上的音频可视化工具</li>
<li><a href="https://www.macbartender.com">Bartender</a> - 隐藏状态栏图标</li>
<li><a href="https://bear.app">Bear</a> - 记笔记</li>
<li><a href="https://www.globaldelight.com/boom/">Boom 3D</a> - Mac 音频增强</li>
<li><a href="https://www.charlesproxy.com/">Charles</a> - Web Debugging Proxy</li>
<li><a href="https://apps.apple.com/cn/app/cleaner-for-xcode/id1296084683?mt=12">Cleaner for Xcode</a>
<ul>
<li><a href="https://github.com/waylybaye/XcodeCleaner-SwiftUI">开源</a>的 Xcode 清理应用</li>
</ul>
</li>
<li><a href="https://cleanshot.com">CleanShot X</a> - 截图</li>
<li><a href="https://www.eudic.net/eudic/mac_dictionary.aspx">Eudic</a> - 词典</li>
<li><a href="https://www.apptorium.com/expressions">Expressions</a> - 正则表达式</li>
<li><a href="https://apps.apple.com/us/app/id1375291184">Flower Password</a> - 密码管理，花密第三方 App
<ul>
<li><a href="https://flowerpassword.com">花密</a> - 花密官网</li>
</ul>
</li>
<li><a href="https://git-fork.com">Fork</a> - Git 管理应用，简洁、易用</li>
<li><a href="https://iina.io">IINA</a> - The modern media player for macOS</li>
<li><a href="https://img2icnsapp.com">Image2icon</a> - 图片转 App 图标</li>
<li><a href="https://imazing.com">iMazing</a> - iPhone 管理</li>
<li><a href="https://apps.apple.com/us/app/id484757536">isHUD</a> - 输入法切换</li>
<li><a href="https://bjango.com/mac/istatmenus">iStat Menus</a> - 状态栏系统状态</li>
<li><a href="https://www.iterm2.com">iTerm</a> - 更强大易用的命令行终端
<ul>
<li>with <a href="http://ohmyz.sh">oh-my-zsh</a></li>
</ul>
</li>
<li><a href="https://www.keka.io/en">Keka</a> - 解压缩</li>
<li><a href="https://karabiner-elements.pqrs.org">Karabiner</a> - 按键映射</li>
<li><a href="https://www.soma-zone.com/LaunchControl">LaunchControl</a> - The launchd GUI</li>
<li><a href="https://www.corecode.io/macupdater">MacUpdater</a> - 软件更新</li>
<li><a href="https://magnet.crowdcafe.com">Magnet</a> - 窗口管理</li>
<li><a href="https://apps.apple.com/us/app/id789066512">Maipo</a> - 微博客户端</li>
<li><a href="https://github.com/Caldis/Mos">Mos</a> - 外接鼠标平滑滚动</li>
<li><a href="https://www.lightpillar.com/mosaic.html">Mosaic</a> - 窗口管理</li>
<li><a href="https://paw.cloud">Paw</a> - HTTP 客户端</li>
<li><a href="https://pdfexpert.com">PDF Expert</a> - PDF 阅读与编辑</li>
<li><a href="https://molunerfinn.com/PicGo">PicGo</a> - 图片上传工具</li>
<li><a href="https://reederapp.com">Reeder</a> - RSS 阅读</li>
<li><a href="https://matthewpalmer.net/rocket">Rocket</a> - 快速输入 Emoji</li>
<li><a href="https://www.realmacsoftware.com/squash">Squash</a> - 图片压缩工具</li>
<li><a href="https://www.sublimetext.com/">Sublime Text</a> - 文本编辑器</li>
<li><a href="https://github.com/nicklockwood/SwiftFormat">SwiftFormat for Xcode</a> - Swift 代码格式化</li>
<li><a href="https://github.com/itsuhane/SwitchKey">SwitchKey</a> - 自动切换输入法</li>
<li><a href="https://tableplus.com">TablePlus</a> - 数据库管理</li>
<li><a href="https://mytab.space">Tab Space</a> - Safari 标签页管理</li>
<li><a href="https://apps.apple.com/us/app/id1114272557">TinyCal</a> - 小而美的日历</li>
<li><a href="https://code.visualstudio.com">VSCode</a> - 编辑器，内部直接使用命令行非常便捷</li>
</ul>
<h2 id="其他-1"><a class="header" href="#其他-1">其他</a></h2>
<ul>
<li><a href="https://github.com/mayswind/AriaNg-Native">AriaNg Native</a> - Aria2 GUI</li>
<li><a href="https://folivora.ai">BetterTouchTool</a> - 自定义触控板手势</li>
<li><a href="https://gumroad.com/l/NQwlK">ClockDock</a> - Dock 栏时钟</li>
<li><a href="https://apps.apple.com/us/app/id1024640650">CotEditor</a> - 文本编辑器</li>
<li><a href="https://kapeli.com/dash">Dash</a> - 开发文档阅读</li>
<li><a href="https://software.charliemonroe.net/downie">Downie</a> - Youtube、Bilibili 等流媒体视频下载</li>
<li><a href="https://hazeover.com">HazeOver</a> - 屏幕遮罩，高亮当前窗口</li>
<li><a href="https://kaleidoscope.app">Kaleidoscope</a> - Diff 差异检查应用，文本、图片、文件夹、开发流集成</li>
<li><a href="https://github.com/macvim-dev/macvim">MacVim</a> - macOS Vim GUI</li>
<li><a href="https://setapp.com">Setapp</a> -付费软件集合</li>
<li><a href="macOS/./snippetsLab.html">SnippetsLab</a> - 代码片段库，支持 iCloud 备份</li>
<li><a href="https://theunarchiver.com">The Unarchiver</a> - 解压缩</li>
</ul>
<h2 id="screen-saver"><a class="header" href="#screen-saver">Screen Saver</a></h2>
<ul>
<li><a href="https://github.com/JohnCoates/Aerial">Aerial</a> - Apple TV Aerial Views Screen Saver</li>
<li><a href="https://github.com/lekevicius/october30">October 30</a> - Randomly changes between 371 Apple logos</li>
<li><a href="https://github.com/bjdehang/100-macos-screensavers">更多</a> - 共收集 37 个屏保</li>
</ul>
<h2 id="链接-3"><a class="header" href="#链接-3">链接</a></h2>
<ul>
<li><a href="https://github.com/jaywcjlove/awesome-mac">Awesome Mac</a> - 优秀好用的 Mac 应用大合集</li>
<li><a href="https://github.com/serhii-londar/open-source-mac-os-apps">Awesome macOS open source applications</a> - macOS 开源应用合集</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编程语言"><a class="header" href="#编程语言">编程语言</a></h1>
<ul>
<li><a href="ProgrammingLanguages/./OC/OC.html">Objective-C</a></li>
<li><a href="ProgrammingLanguages/./Swift/Swift.html">Swift</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift"><a class="header" href="#swift">Swift</a></h1>
<ul>
<li><a href="ProgrammingLanguages/Swift/./AdvancedSwift.html">《Swift 进阶》阅读纪要</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift-进阶阅读纪要"><a class="header" href="#swift-进阶阅读纪要">《Swift 进阶》阅读纪要</a></h1>
<p>《<a href="https://objccn.io/products/advanced-swift/">Swift 进阶</a>》是 objc.io 出的<a href="https://objccn.io/products/">系列书籍</a>之一。</p>
<p>在此记录阅读笔记。</p>
<ul>
<li><a href="ProgrammingLanguages/Swift/AdvancedSwift.html#%E5%86%85%E5%BB%BA%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B">内建集合类型</a></li>
<li><a href="ProgrammingLanguages/Swift/AdvancedSwift.html#%E5%8F%AF%E9%80%89%E5%80%BC">可选值</a></li>
<li><a href="ProgrammingLanguages/Swift/AdvancedSwift.html#%E5%87%BD%E6%95%B0">函数</a></li>
<li><a href="ProgrammingLanguages/Swift/AdvancedSwift.html#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB">结构体和类</a></li>
<li><a href="ProgrammingLanguages/Swift/AdvancedSwift.html#%E6%9E%9A%E4%B8%BE">枚举</a></li>
<li><a href="ProgrammingLanguages/Swift/AdvancedSwift.html#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a href="ProgrammingLanguages/Swift/AdvancedSwift.html#%E5%8D%8F%E8%AE%AE">协议</a></li>
<li><a href="ProgrammingLanguages/Swift/AdvancedSwift.html#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a></li>
<li><a href="ProgrammingLanguages/Swift/AdvancedSwift.html#%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81">编码和解码</a></li>
</ul>
<h2 id="内建集合类型"><a class="header" href="#内建集合类型">内建集合类型</a></h2>
<blockquote>
<p>Swift 标准库中的所有集合类型都使用了“写时复制”这一技术，它能够保证只在必要的时候对数据进行复制。</p>
</blockquote>
<blockquote>
<p>从内存安全的角度上说，下标操作是完全安全的，标准库中的集合总是会执行边界检查，并禁止那些越界索引对内存的访问。</p>
</blockquote>
<blockquote>
<p><strong>官方标准库中的 <code>map</code> 版本没有指定它是否会按顺序来处理序列</strong>，不过看起来现在这么做是安全的。</p>
</blockquote>
<blockquote>
<p><strong>在 <code>forEach</code> 中的 <code>return</code> 并不能让外部函数返回，它仅仅只是让闭包本身返回。</strong></p>
</blockquote>
<blockquote>
<p>需要谨记的是切片和它背后的数组是使用相同的索引来引用元素的。因此，切片索引不需要从零开始。如果你操作切片的话，我们建议你总是基于 <code>startIndex</code> 和 <code>endIndex</code> 属性做索引计算。</p>
</blockquote>
<blockquote>
<p>Dictionary 有一个 <code>merge(_:uniquingKeysWith:)</code>，它接受两个参数，第一个是要进行合并的键值对，第二个是定义如何合并相同键的两个值的函数。</p>
</blockquote>
<blockquote>
<p>标准库中所有的基本数据类型都是遵守 Hashable 协议的，它们包括字符串，整数，浮点数以及布尔值。另外，像是数组，集合和可选值这些类型，如果它们的元素都是可哈希的，那么它们自动成为可哈希的。</p>
</blockquote>
<blockquote>
<p>对于结构体和枚举，只要它们是由可哈希的类型组成，那么 Swift 就可以帮我们自动合成 Hashable 协议所需要的实现。如果一个结构体的所有存储属性都是可哈希的，那么我们不用手动实现 Hashable 协议，结构体就已经实现这个协议了。类似的，只要枚举包含可哈希的关联值，那么就可以自动实现这个协议；对于那些没有关联值的枚举，甚至都不用显式声明要实现 Hashable 协议。</p>
</blockquote>
<blockquote>
<p>标准库的通用哈希函数使用一个随机种子作为其输入之一。也就是说，字符串 &quot;abc&quot; 的哈希值在每次程序执行时都会是不同的。随机种子是一种用来防止有针对性的哈希洪泛式拒绝服务攻击的安全措施。因为字典和集合是按照存储在哈希表中的顺序来迭代它们的元素，并且由于这个顺序是由哈希值决定的，所以这意味着相同的代码在每次执行时会产生不同的迭代顺序。如果你需要哈希值每次都一样，例如为了测试，那么可以通过设置环境变量 <code>SWIFT_DETERMINISTIC_HASHING=1</code> 来禁用随机种子，但是你不应该在正式环境中这么做。</p>
</blockquote>
<blockquote>
<p>当你使用不具有值语义的类型 (比如可变的对象) 作为字典的键时，需要特别小心。如果你在将一个对象用作字典键后，改变了它的内容，它的哈希值和/或相等特性往往也会发生改变。这时候你将无法再在字典中找到它。这时字典会在错误的位置存储对象，这将导致字典内部存储的错误。对于值类型来说，因为字典中的键不会和复制的值共用存储，因此它也不会被从外部改变，所以不存在这个的问题。</p>
</blockquote>
<blockquote>
<p><code>Set</code> 和 <code>OptionSet</code> 是标准库中唯一实现了 <code>SetAlgebra</code> 的类型，但是这个协议在 Foundation 中还被另外两个很有意思的类型实现了：那就是 <code>IndexSet</code> 和 <code>CharacterSet</code>。</p>
</blockquote>
<blockquote>
<p><code>IndexSet</code> 表示了一个由正整数组成的集合。当然，你可以用 <code>Set&lt;Int&gt;</code> 来做这件事，但是 <code>IndexSet</code> 更加高效，因为它内部使用了一组范围列表进行实现。打个比方，现在你有一个含有 1000 个元素的 table view，你想要一个集合来管理已经被用户选中的元素的索引。使用 <code>Set&lt;Int&gt;</code> 的话，根据选中的个数不同，最多可能会要存储 1000 个元素。<strong>而 <code>IndexSet</code> 不太一样，它会存储连续的范围，也就是说，在选取前 500 行的情况下，<code>IndexSet</code> 里其实只存储了选择的首位和末位两个整数值</strong>。</p>
</blockquote>
<blockquote>
<p><code>CharacterSet</code> 是一个高效的存储 Unicode 编码点 (<code>code point</code>) 的集合。和 <code>IndexSet</code> 有所不同，<code>CharacterSet</code> 并不是一个集合类型。</p>
</blockquote>
<blockquote>
<p>只有半开范围能表达空间隔 (也就是下界和上界相等的情况，比如 <code>5..&lt;5</code>)。</p>
</blockquote>
<h2 id="可选值"><a class="header" href="#可选值">可选值</a></h2>
<blockquote>
<p>一个返回 <code>Never</code> 的函数用于通知编译器：它绝对不会返回。有两类常见的函数会这么做：一种是像 <code>fatalError</code> 那样表示程序失败的函数，另一种是像 <code>dispatchMain</code> 那样运行在整个程序生命周期的函数。编译器会使用这个信息来检查和确保控制流正确。举例来说，<code>guard </code>语句的 <code>else</code> 路径必须退出当前域或者调用一个不会返回的函数。</p>
</blockquote>
<blockquote>
<p><code>Never</code> 又被叫做<strong>无人类型</strong> (uninhabited type)。这种类型没有有效值，因此也不能够被构建。在 Swift 中，无人类型是通过一个不包含任意成员的 enum 实现的：<code>public enum Never { }</code>。</p>
</blockquote>
<blockquote>
<p><code>Void</code> 是空元组 (tuple) 的另一种写法：<code>public typealias Void = ()</code>。</p>
</blockquote>
<blockquote>
<p>正如 David Smith 所指出的，Swift 对“东西不存在”(<code>nil</code>)，“存在且为空”(<code>Void</code>) 以及 “不可能发生” (<code>Never</code>) 这几个概念进行了仔细的区分。</p>
</blockquote>
<blockquote>
<p>一个有点古怪 (但逻辑上合理) 的边界情况是你完全可以像下面这样直接给 Optional 赋值：</p>
<pre><code class="language-swift">var a: Int? = 5
a? = 10
a // Optional(10)
var b: Int? = nil
b? = 10
b // nil
</code></pre>
<p>请注意 <code>a = 10</code> 和 <code>a? = 10</code> 的细微不同。前一种写法无条件地将一个新值赋给变量，而后一种写法只在 <code>a</code> 的值在赋值发生前不是 <code>nil</code> 的时候才生效。</p>
</blockquote>
<blockquote>
<p><code>a ?? b ?? c</code> 和 <code>(a ?? b) ?? c</code>。前者是合并操作的链接，而后者是先解包括号内的内容，然后再处理外层：</p>
<pre><code class="language-swift">let s1: String?? = nil // nil
(s1 ?? &quot;inner&quot;) ?? &quot;outer&quot; // inner
let s2: String?? = .some(nil) // Optional(nil)
(s2 ?? &quot;inner&quot;) ?? &quot;outer&quot; // outer
</code></pre>
</blockquote>
<blockquote>
<p>可选值的 <code>map</code> 方法只会操作一个值，那就是该可选值中的那个可能存在的值。你可以把可选值当作一个包含零个或者一个值的集合，这样 <code>map</code> 要么在零个值的情况下不做处理，要么在有值的时候会对其进行转换。</p>
</blockquote>
<blockquote>
<p>当你在使用一个非可选值的时候，如果需要匹配成可选值类型，Swift 总是会将它“升级”为一个可选值。</p>
</blockquote>
<blockquote>
<p>其实，你可能会留一个注释来提醒为什么这里要使用强制解包。那为什么不把这个注释直接作为错误信息呢？这里我们加了一个 <code>!!</code> 操作符，它将强制解包和一个更具有描述性质的错误信息结合在一起，当程序意外退出时，这个信息也会被打印出来：</p>
<pre><code class="language-swift">infix operator !!
func !! &lt;T&gt;(wrapped: T?, failureText: @autoclosure () -&gt; String) -&gt; T {
  if let x = wrapped { return x }
  fatalError(failureText())
}
</code></pre>
<p>现在你可以写出更能描述问题的错误信息了，它还包括了你期望的被解包的值：</p>
<pre><code class="language-swift">let s = &quot;foo&quot;
let i = Int(s) !! &quot;Expecting integer, got \&quot;\(s)\&quot;&quot;
</code></pre>
</blockquote>
<blockquote>
<pre><code class="language-swift">infix operator !?
func !?&lt;T: ExpressibleByIntegerLiteral&gt;
    (wrapped: T?, failureText: @autoclosure () -&gt; String) -&gt; T
{
  assert(wrapped != nil, failureText())
  return wrapped ?? 0
}
</code></pre>
</blockquote>
<h2 id="函数"><a class="header" href="#函数">函数</a></h2>
<blockquote>
<p>Swift 只允许在函数声明中包含标签，这些标签不是函数类型的一部分。</p>
</blockquote>
<blockquote>
<p>一个函数和它所捕获的变量环境组合起来被称为闭包。</p>
</blockquote>
<blockquote>
<p>如果一个函数除了闭包表达式外没有别的参数，那么调用的时候在方法名后面的圆括号也可以一并省略。</p>
</blockquote>
<blockquote>
<p>一个 <code>inout</code> 参数持有一个传递给函数的值，函数可以改变这个值，然后从函数中传出并替换掉原来的值。</p>
</blockquote>
<blockquote>
<p><code>lazy</code> 关键字不会进行任何线程同步。</p>
</blockquote>
<blockquote>
<p>Swift 提供了一个 <code>withoutActuallyEscaping</code> 函数来作为一种“安全出口”。这个函数允许你对一个接受逃逸闭包的函数，传入一个非逃逸的闭包。</p>
</blockquote>
<h2 id="结构体和类"><a class="header" href="#结构体和类">结构体和类</a></h2>
<blockquote>
<p>要理解在属性和变量上用 <code>let</code> 和 <code>var</code> 的所有不同组合的关键是要记住两点：</p>
<ul>
<li>类型为类的变量的值，是一个指向实例的引用；而类型为结构体的变量的值，是结构体实例本身。</li>
<li>修改一个结构体的属性，即使修改的是多层的嵌套属性，都等同于给变量赋值一个全新的结构体实例。</li>
</ul>
</blockquote>
<blockquote>
<p>就像对待普通的参数一样，Swift 还是会复制传入的 <code>inout</code> 参数，但当函数返回时，会用这些参数的值覆盖原来的值。也就是说，即使在函数中对一个 <code>inout</code> 参数做多次修改，但对调用者来说只会注意到一次修改的发生，也就是在用新的值覆盖原有值的时候。同理，即使函数完全没有对 <code>inout</code> 参数做任何的修改，调用者也还是会注意到一次修改 (<code>willSet</code> 和 <code>didSet</code> 这两个观察者方法都会被调用)。</p>
</blockquote>
<blockquote>
<p>当对象没有任何强引用的时候，会释放所有资源 (例如，对其他对象的引用)。然而，只要对象还有 unowned 引用存在，其自身所占用的内存就不会被回收。这块内存会被标记为无效，有时也称作僵尸内存 (zombie memory)。被标记为僵尸内存之后，只要我们尝试访问这个 unowned 引用，就会发生一个运行时错误。
但我们也可以通过 <code>unowned(unsafe)</code> 来绕过这个保护机制，当访问一个被标记为 <code>unowned(unsafe)</code> 的无效引用时，行为是未定义的。</p>
</blockquote>
<blockquote>
<p>捕获列表（capture list）可以做的不仅仅只是将变量标记为 <code>weak</code> 或 <code>unowned</code>。比如，如果我们想有一个指向 window 的弱引用变量的话，可以直接在捕获列表中初始化这样一个变量；或者甚至可以在其中定义完全不相关的变量。</p>
</blockquote>
<blockquote>
<p>如果你可以保证，非强引用的对象与持有这个引用的对象的生命周期是一样的，甚至于更长的话，<code>unowned</code> 引用通常是更方便的。因为它的类型不需要是可选值，并可以被声明为 <code>let</code>，而弱引用则必须是用 <code>var</code> 声明的可选值。
相比弱引用，<code>unowned</code> 引用的开销也小一点，通过它访问属性或调用方法的速度会快一点点。</p>
</blockquote>
<blockquote>
<p>对于长度最多只有15个 UTF-8 编码单元 (code unit) 的短字符串，Swift 实现了一种优化来避免为其分配一个缓冲区。</p>
</blockquote>
<blockquote>
<p>我们可以使用 <code>isKnownUniquelyReferenced</code> 函数来检查一个引用类型的实例是否只有一个所有者。 如果你把一个 Swift 的类实例传递给此函数，并且这个实例没有其他强引用的话，这个函数就返回 <code>true</code>，反之，如果有其他强引用存在，此函数返回 <code>false</code>。
虽然这个函数是线程安全的，但是，你必须保证传入的变量不会被另外一个线程所访问，这个限制不单单只是针对 <code>isKnownUniquelyReferenced</code>，它适用于所有的 <code>inout</code> 参数。换言之，<code>isKnownUniquelyReferenced</code> 不能防止竞争条件 (race condition)。</p>
</blockquote>
<h2 id="枚举"><a class="header" href="#枚举">枚举</a></h2>
<blockquote>
<p>一个类型，是它的实例所能表示的所有可能的值的集合，值也被称为居民 (inhabitant)。
<code>Bool</code> 有两个居民，<code>false</code> 和 <code>true</code>。<code>UInt8</code> 有 28，也就是 256 个居民。<code>Int64</code> 有 2^64，也就是大约 1.84 千京 (千京等于 1019) 个居民。像是字符串这种类型，至少在填满内存之前，会有无穷多的居民，因为你总是可以通过追加一个字符来创建另一个字符串。</p>
</blockquote>
<blockquote>
<p>通常来说，一个元组 (或者结构体，类) 的居民数量，等于其成员的居民数量的乘积。因此，结构体，类和元组也被称为<strong>乘积类型 (Product Types)</strong>。
一般而言，一个枚举的居民数量，等于它所有成员的居民数量的总和。这也是为什么称枚举为 <strong>总和类型（Sum Types）</strong> 的原因。</p>
</blockquote>
<blockquote>
<p>在 <code>switch</code> 语句中，<code>case _ </code>是等同于 <code>default</code> 关键字的：两者都匹配任意值，并且把它们作为最后一个分支才是合理的。</p>
</blockquote>
<blockquote>
<p>为了忽略一个关联值，可以在子模式中使用下划线，或删除整个子模式来达到目的，例如，<code>.success(_)</code> 和 <code>.success</code> 就是等价的。</p>
</blockquote>
<blockquote>
<p><strong>一个 <code>switch</code> 语句必须是完备的</strong>，也就是说，它的分支必须覆盖所有可能的输入值。编译器也会强制执行这个完备性。
因此我们建议你<strong>尽可能避免在 <code>switch</code> 语句中使用 <code>default</code> 分支</strong>。</p>
</blockquote>
<blockquote>
<p>一个系统可以存在的状态集合也称为其状态空间。</p>
</blockquote>
<blockquote>
<p>对于没有关联值的枚举，编译器会自动生成实现 <code>CaseIterable</code> 的代码；
<code>CaseIterable</code> 协议没有规定 <code>allCases</code> 返回的集合中的值的特定顺序，但 <code>CaseIterable</code> 的文档中则保证集合中的值的顺序是和它们在声明时的顺序所一致的。</p>
</blockquote>
<blockquote>
<p><code>allCases</code> 的返回类型不必一定是数组 - 它可以是任何一个实现了 <code>Collection</code> 的类型。</p>
</blockquote>
<blockquote>
<p><strong>不要让你所不拥有的类型去实现你不拥有的协议。</strong></p>
</blockquote>
<blockquote>
<p>可能会在未来添加新成员的枚举，称之为非固定。
在一个模块中 <code>switch</code> 另一个模块中的非固定枚举的话，必须始终包含一个 <code>default</code> 子句，以便能够处理将来会发生的这种情况。
<strong>尽量避免使用嵌套 switch 语句</strong>。你可以使用元组一次性匹配多个值。</p>
</blockquote>
<blockquote>
<p><strong>利用明确初始化检查 (definite initialization check)。</strong>
编译器会在首次使用一个变量之前去验证这个变量是否已完全初始化了 - 如果我们在一条或多条代码路径中忘记初始化的话，编译器会产生一个错误。
<strong>避免用 <code>none</code> 或 <code>some</code> 来命名成员。</strong>
<strong>对那些用保留的关键字来命名的成员使用反引号 (backtick)。</strong>
可以像工厂方法一样使用成员。如果一个成员拥有关联值的话，这个枚举值就单独地形成了一个签名为 <code>(AssocValue) -&gt; Enum</code> 的函数。
<strong>不要使用关联值来模拟存储属性。请改用结构体。</strong></p>
</blockquote>
<blockquote>
<p>这是一个通用模式：当你发现一个枚举中每个成员的关联值都有一部分是相同的，请考虑把这个枚举封装到一个结构体中，并把公共部分提取出来。这会改变结果类型的样子，但不会改变其基本性质。这和在数学等式中提取公因子是一样的：<code>a x b + a x c = a x (b + c)</code>。这种与代数的对应关系也解释了为什么把<strong>总和类型和乘积类型总称为“代数数据类型”</strong>。</p>
</blockquote>
<blockquote>
<p><strong>把空枚举作为命名空间</strong>。除了由模块形成的隐式命名空间之外，Swift 没有内置的命名空间。但我们可以用枚举来“模拟”命名空间。由于类型定义是可以嵌套的，因此外部类型可以充当其包含的所有声明的命名空间。</p>
</blockquote>
<h2 id="字符串"><a class="header" href="#字符串">字符串</a></h2>
<blockquote>
<p>一个 Unicode 字符，也叫做扩展字位簇 (extended grapheme cluster)，由一个或多个 Unicode 标量 (Unicode scalar) 组成。
一个 Unicode 标量可以被编码成一个或多个编码单元 (code units)。
Unicode 中最基础的原件叫做编码点 (code point)：它是一个位于 Unicode 编码空间 (从 0 到 0x10FFFF，也就是十进制的 1,114,111) 中的整数。
Unicode 标量和刚才提到的编码点，在绝大多数情况下，是同一个东西。或者说，除了编码点中 0xD800 - 0xDFFF 之外的值，都可以叫做 Unicode 标量。而 0xD800 - 0xDFFF 这 2048 个值则叫做 代理编码点 (surrogate code points)，它们在 UTF-16 编码中用于表示那些值大于 65535 的字符。
提及到“字符”这个概念，Unicode 仍就是一个可变宽度的格式。因为用户在屏幕上看到的“单个字符”，可能是由多个 Unicode 标量组合起来的。对于这种用户感知到的“单个字符”，Unicode 中有一个术语，叫做 (扩展) 字位簇，对应的英文叫做 (extended) grapheme cluster。</p>
</blockquote>
<blockquote>
<p>如果你真要按照标准等价的方式进行比较两个 <code>NSString</code>，就得使用 <code>NSString.compare(_:)</code> 方法。</p>
</blockquote>
<blockquote>
<p><code>CR+LF</code> 字符表示回车 (carriage return) 和换行 (line feed) 的组合</p>
</blockquote>
<blockquote>
<p>Unicode 的解决方案是把这种复杂的颜文字表示成一个简单颜文字的序列，序列中的颜文字则通过一个标量值为 U+200D 的不可见零宽连接字符 (zero-width joiner，ZWJ) 连接。因此，家庭颜文字 👨‍👩‍👧‍👦 是由男人 👨 + ZWJ + 女人 👩 + ZWJ + 女孩 👧 + ZWJ + 男孩 👦 构成的。ZWJ 的存在，是对操作系统的提示，表明如果可能的话，把 ZWJ 连接的字符当成一个字形符号 (glyph) 处理。
在 2016 年引入的代表职业的颜文字也是 ZWJ 序列。比如，一个女性消防员 👩‍🚒 是女人 👩 + ZWJ + 消防车 🚒, 的组合。而男性医护工作者 👨‍⚕️ 则是男人 👨 + ZWJ + 医疗之神阿斯克勒庇俄斯的权杖 ⚕ 的序列。</p>
</blockquote>
<blockquote>
<p><code>Substring</code> 和 <code>ArraySlice</code> 很相似：它是一个以原始字符串内容为基础，用不同起始和结束位置标记的视图。<strong>子字符串和原字符串共享文本存储</strong>。</p>
</blockquote>
<blockquote>
<p>utf8 集合不包含字符串尾部的 null 字节。如果你需要用 null 表示结尾的话，可以使用 <code>String</code> 的 <code>withCString</code> 方法或者 <code>utf8CString</code> 属性。</p>
</blockquote>
<blockquote>
<p>Swift 字符串在内存中的原生编码是 UTF-8，而 NSString 是 UTF-16。</p>
</blockquote>
<blockquote>
<p>Foundation 中用来显示带有格式的富文本的 <code>NSAttributedString</code> 就是一例。要在 Swift 中成功使用属性字符串，你必须注意下面这些：</p>
<ul>
<li>有两个类，<code>NSAttributedString</code> 对应不可变字符串，<code>NSMutableAttributedString</code> 对应可变字符串。和 Swift 标准库中遵守值语义的集合不同，它们都遵守引用语义。</li>
<li>虽然 <code>NSAttributedString</code> 的 API 原来接受的是 <code>NSString</code>，但是它现在接受一个 <code>Swift.String</code>。不过整个 API 的基础还是 <code>NSString</code> 的 UTF-16 编码单元集合的概念。频繁地在 <code>String</code> 和 <code>NSString</code> 之间发生桥接可能会带来意外的性能开销。</li>
</ul>
</blockquote>
<blockquote>
<p>但如果你没有实现 <code>CustomDebugStringConvertible</code>，<code>String(reflecting:)</code> 就会选择使用 <code>CustomStringConvertible</code> 提供的结果，反之也是。如果你的类型没有实现<code>CustomStringConvertible</code>，<code>String(describing:)</code> 会选择使用 <code>CustomDebugStringConvertible</code> 提供的结果。</p>
</blockquote>
<blockquote>
<p><code>Array</code> 总是会打印它包含的元素的调试版信息。</p>
</blockquote>
<h2 id="协议"><a class="header" href="#协议">协议</a></h2>
<blockquote>
<p>带有默认实现的协议方法在 Swift 社区中有时也叫做定制点 (customization point)。</p>
</blockquote>
<blockquote>
<p>当我们把协议当作具体类型使用的时候，编译器会为协议创建一个包装类型，叫做<strong>存在体 (existential)</strong>。<code>let context: DrawingContext</code> 这种写法本质上就是类似 <code>let context: Any&lt;DrawingContext&gt;</code> 这种写法的语法糖。尽管这种语法并不存在，编译器会创建一个 (32 字节的) <code>Any</code> 盒子，并在其中为类型实现的每个协议添加一个 8 字节的协议目击者。
为协议创建的这个盒子也叫做 <strong>存在体容器 (existential container)</strong>。这是编译器必须要做的事情，因为它需要在编译期确认类型的大小。不同的类型自身大小有差异 (例如：所有的类都是一个指针的大小，而结构体和枚举的大小则依赖它们的实际内容)，这些类型实现了一个协议的时候，把协议包装在存在体容器中可以让类型的尺寸保持固定，编译器也就能确定对象的内存布局了。</p>
</blockquote>
<h2 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h2>
<blockquote>
<p>Swift 的异常机制并不会像很多语言那样带来额外的运行时开销。编译器会认为 <code>throw</code> 是一个普通的返回，这样一来，普通的代码路径和异常的代码路径速度都会很快。</p>
</blockquote>
<blockquote>
<p>我们也可以把一个结构体或者类作为错误类型来使用；任何遵守 Error 协议的类型都可以被函数作为错误抛出。而且由于 <code>Error</code> 协议中其实并没有任何要求，所以任何类型都可以声明遵守它，而并不需要添加任何额外的实现。
为了快速测试某些代码，或者编写一些简单原型的时候，我们发现，让 <code>String</code> 实现 <code>Error</code> 有时会很有帮助。只需要一行代码就可以搞定了：<code>extension String: Error {}</code>。这样，就可以直接把表达错误消息的字符串作为可抛出的错误值使用，例如：<code>throw &quot;File not found&quot;</code>。在生产环境的代码里，我们并不推荐如此，因为<strong>让一个不属于你的类型实现某个协议并不是值得推荐的做法</strong>。</p>
</blockquote>
<blockquote>
<p>Swift 原生的错误处理机制使用了<strong>无类型错误 (untyped errors)</strong>。我们只能用 <code>throws</code> 声明函数会抛出错误，但无法指定它究竟会抛出哪些具体的错误。因此，为了从语言层面确保所有错误都可以被处理，编译器才总是要求我们编写一个 <code>catchall</code> 语句。在错误处理系统中使用无类型错误是 Swift 核心团队刻意为之的。原因是在大部分情况下，巨细无遗的错误处理是不现实也没必要的。通常，你可能只关心一两个特定的错误情况，然后给其它错误在 <code>catchall</code> 语句中提供一个通用的处理方法就好了。</p>
</blockquote>
<blockquote>
<p><code>Result</code>，则属于<strong>具体类型错误 (typed errors)</strong>。<code>Result</code> 带有两个泛型参数，<code>Success</code> 和 <code>Failure</code>，而后者指定了错误的具体类型。
<code>Result</code> 实际上是一个同时支持两种错误处理范式的混合体。如果你不希望指定具体的错误类型，就用 <code>Result&lt;..., Error&gt;</code> 作为返回值就行了。</p>
</blockquote>
<blockquote>
<p>错误链</p>
<ul>
<li>throw 链
<ul>
<li>我们不需要使用嵌套的 <code>if</code> 语句或者类似的结构来保证代码运行，只要简单地将这些函数调用放到一个 <code>do/catch</code> 代码块中 (或者封装到一个被标记为 <code>throws</code> 的函数中) 就好了。当遇到第一个错误时，调用链将结束，代码将被切换到 <code>catch</code> 块中，或者传递到上层调用者去。</li>
</ul>
</li>
<li>Result 链
<ul>
<li>我们必须用 <code>mapError</code> (这是 <code>Result</code> 提供的方法) 对错误类型再进行一次转换。</li>
<li><code>Result.flatMap</code> 方法封装了这种根据 <code>Result</code> 结果决定是要继续向下个环节传递成功值，还是由于失败必须退出调用链的模式。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>和 <code>finally</code> 不同的是，<code>defer</code> 不需要前置的 <code>try</code> 或 <code>do</code> 代码块，你可以把它部署到代码中的任何地方。</p>
</blockquote>
<blockquote>
<p>如果相同的作用域中有多个 <code>defer</code> 代码块，它们将按照定义的顺序逆序执行。</p>
</blockquote>
<blockquote>
<p>一个 <code>defer</code> 代码块会在程序离开 <code>defer</code> 定义的作用域时被执行。甚至 <code>return</code> 语句的评估都会在同作用域的 <code>defer</code> 被执行之前完成。</p>
</blockquote>
<blockquote>
<p>Swift 通过 <code>rethrows</code> 关键字提供了一个更好的方案。用 <code>rethrows</code> 标记一个函数就相当于告诉编译器：这个函数只有它的参数抛出错误的时候，它才会抛出错误。</p>
</blockquote>
<blockquote>
<p>将错误桥接到 Objective-C</p>
<pre><code>// Objective-C 版本的 `contents(ofFile:)` 写出来可能是这样的：
- (NSString *)contentsOfFile(NSString *)filename error:(NSError **)error;

// Swift
func contents(ofFile filename: String) throws -&gt; String
</code></pre>
<p>Swift 会自动把遵循这个规则 (译注：这个规则指的是接受 <code>NSError **</code> 作为参数) 的方法转换为 <code>throws</code> 语法的版本。因为不再需要参数传递错误了，它会从声明中删除。
签名的转换过程除了会删除 <code>NSError **</code> 类型的参数之外，对于那些返回 <code>BOOL</code> 来表示操作成功与否的函数，例如 <code>createDirectoryAtPath</code>，转换到 Swift 之后也会变成一个 <code>throws</code> 函数，也就不再需要使用 <code>BOOL</code> 表示调用结果了，因此，<code>BOOL</code> 会变成 Void。</p>
</blockquote>
<blockquote>
<p>如果你把一个 Swift 错误传递给 Objective-C 的方法，类似地，它将被桥接为 <code>NSError</code>。因为所有的 <code>NSError</code> 对象都必须有一个 <code>domain</code> 字符串和一个整数的错误代码 <code>code</code>，运行时将在必要的时候提供默认值，它会使用类型名作为 <code>domain</code>，使用从 0 开始的枚举的序号作为错误代码。如果有需要，你也可以让你的错误类型遵守 <code>CustomNSError</code> 协议来提供自定义的值。</p>
</blockquote>
<blockquote>
<p>你还可以实现下面这两个协议，来让你的错误拥有更有意义的描述，并且更好地遵循 Cocoa 的习惯：</p>
<ul>
<li><code>LocalizedError</code> — 提供一个本地化的信息，来表示错误为什么发生 (failureReason)，从错误中恢复的提示 (recoverySuggestion) 以及额外的帮助文本 (helpAnchor)。</li>
<li><code>RecoverableError</code> — 描述一个用户可以恢复的错误，展示一个或多个 recoveryOptions，并在用户要求的时候执行恢复。这多用于使用了 AppKit 的 macOS 应用。
就算没有实现 <code>LocalizedError</code> 协议，所有实现了 <code>Error</code> 的类型也会有一个可以重写的 <code>localizedDescription</code> 属性。</li>
</ul>
</blockquote>
<blockquote>
<p>实现 <code>Error</code> 的那些类型也可以定义自己的 <code>localizedDescription</code>。不过，因为这并不是 <code>Error</code> 协议所要求的，这个属性也不支持动态派发。除非你也遵守了 <code>LocalizedError</code>，否则在 Objective-C 的 API 或者 <code>Error</code> 的存在体容器 (existential container) 里，你将不能使用这个自定义的 <code>localizedDescription</code>。当编写 Cocoa 应用的时候，你应该总是让传递给 Cocoa API 的错误类型实现 <code>LocalizedError</code> 协议。</p>
</blockquote>
<h2 id="编码和解码"><a class="header" href="#编码和解码">编码和解码</a></h2>
<blockquote>
<p>实际上，<code>JSONEncoder</code> 甚至都没有实现 <code>Encoder</code> 协议。相反，它只是一个叫做 <code>_JSONEncoder</code> 的私有类的封装，这个私有类实现了 <code>Encoder</code> 协议，并且进行实际的编码工作。之所以这样做，是因为顶层编码器 (译注：这里指 <code>JSONEncoder</code>) 应该提供的 API (这个 API 通常只用于启动编码过程)，和在编码过程中传递给可编码类型的 <code>Encoder</code> 对象 (译注：这里指 <code>_JSONEncoder</code>) 是截然不同的。将这些任务清晰地分开，意味着在任意给定的情景下，使用编码器的一方只能访问到适当的 API。</p>
</blockquote>
<blockquote>
<p>容器有三种类型：</p>
<ul>
<li><strong>键容器 (Keyed Container)</strong> 用于编码键值对。可以把键容器想像为一个特殊的字典，这是到目前为止，应用最普遍的容器。
键容器内部使用的键是强类型的，这为我们提供了类型安全和自动补全的特性。编码器最终会在写入目标格式 (比如 JSON) 时，将键转换为字符串 (或者数字)，不过这对开发者来说是隐藏的。修改编码后的键名是最简单的一种自定义编码方式的操作，我们将会在下面看到一些相关的例子。</li>
<li><strong>无键容器 (Unkeyed Container)</strong> 用于编码一系列值，但不需要对应的键，可以将它想像成保存编码结果的数组。因为没有对应的键来确定某个值，所以对无键容器中的值进行解码的时候，需要遵守和编码时同样的顺序</li>
<li><strong>单值容器</strong>对单一值进行编码。你可以用它来处理只由单个属性定义的那些类型。例如：<code>Int</code> 这样的原始类型，或以原始类型实现了 <code>RawRepresentable</code> 协议的枚举。</li>
</ul>
</blockquote>
<blockquote>
<p>所有键都必须可以用字符串的形式表示，另外，一个键类型也可以提供和整数互相转换的能力。如果使用整数更高效，编码器会选择整数形式的键。但它们也可以完全忽略掉这个特性而坚持使用字符串键，而 <code>JSONEncoder</code> 就是这么做的。因此，编译器合成的默认代码也只包含了字符串键。</p>
</blockquote>
<blockquote>
<p><code>Range</code>，它使用无键容器来编码上下边界。</p>
</blockquote>
<blockquote>
<p>和编码器类似，解码器也管理一棵由解码容器 (decoding containers) 构成的树，树中所包含的容器我们已经很熟悉了，它们还是键容器，无键容器，以及单值容器。</p>
</blockquote>
<blockquote>
<p>Swift 只在两种情况下会自动合成协议实现的代码，分别是直接添加在类型定义上的协议，以及定义在同一个文件的类型扩展上的协议。</p>
</blockquote>
<blockquote>
<p>“实际上我会更进一步，并且建议在当你想要扩展别人的类型，使其满足 <code>Encodable</code> 或 <code>Decodable</code> 时，你几乎总是应该考虑写一个结构体把它封装起来，除非你有理由能够确信这个类型自己绝对不会去遵循这些协议。” —— Apple 的工程师 Itai Ferber</p>
</blockquote>
<blockquote>
<p>另一种方案是使用嵌套容器来编码经纬度。<code>KeyedDecodingContainer</code> 有一个叫做 <code>nestedContainer(keyedBy:forKey:)</code> 的方法，它可以在 <code>forKey</code> 指定的键上，新建一个嵌套的键容器 (译注：想象一下，原本这个键对应的应该是在原始容器中保存的编码结果)，这个嵌套键容器使用 <code>keyedBy</code> 参数指定的另一套编码键。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objective-c"><a class="header" href="#objective-c">Objective-C</a></h1>
<ul>
<li><a href="ProgrammingLanguages/OC/./OCNote.html">OC 底层学习笔记</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oc-底层学习笔记"><a class="header" href="#oc-底层学习笔记">OC 底层学习笔记</a></h1>
<ul>
<li><a href="ProgrammingLanguages/OC/OCNote.html#oc%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">OC 底层学习笔记</a>
<ul>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a>
<ul>
<li><a href="ProgrammingLanguages/OC/OCNote.html#oc-cc">OC -&gt; C/C++</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E4%B8%80%E4%B8%AAnsobject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98%EF%BC%9F">一个 NSObject 对象占用多少内存？</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E5%AF%B9%E8%B1%A1%E7%9A%84isa%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E5%93%AA%E9%87%8C%EF%BC%9F">对象的 isa 指针指向哪里？</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#oc%E7%9A%84%E7%B1%BB%E4%BF%A1%E6%81%AF%E5%AD%98%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F">OC 的类信息存放在哪里？</a></li>
</ul>
</li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#kvo">KVO</a>
<ul>
<li><a href="ProgrammingLanguages/OC/OCNote.html#ios%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84-kvo%EF%BC%9F%EF%BC%88kvo%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%89">iOS 使用什么方式实现一个对象的 KVO？（KVO 的本质是什么？）</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91kvo">如何手动触发 KVO</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%E4%BC%9A%E8%A7%A6%E5%8F%91kvo%E4%B9%88%EF%BC%9F">直接修改成员变量的值会触发 KVO 么？</a></li>
</ul>
</li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#kvc">KVC</a>
<ul>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E9%80%9A%E8%BF%87kvc%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7%E4%BC%9A%E8%A7%A6%E5%8F%91-kvo%E4%B9%88%EF%BC%9F">通过 KVC 修改属性会触发 KVO 么？</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#setvalue-forkey%E5%8E%9F%E7%90%86"><code>setValue:forKey:</code> 原理</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#valueforkey%E5%8E%9F%E7%90%86"><code>valueForKey:</code> 原理</a></li>
</ul>
</li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#category">Category</a>
<ul>
<li><a href="ProgrammingLanguages/OC/OCNote.html#category%E7%9A%84%E5%8E%9F%E7%90%86">Category 的原理</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#category%E5%92%8C-class-extension%E7%9A%84%E5%8C%BA%E5%88%AB">Category 和 Class Extension 的区别</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#load%E6%96%B9%E6%B3%95">+load 方法</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#initialize%E6%96%B9%E6%B3%95">+initialize 方法</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E7%BB%99category%E6%B7%BB%E5%8A%A0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">给 Category 添加成员变量</a>
<ul>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1">关联对象</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E7%9A%84key%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95">关联对象的 key 的常见用法</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#objc-associationpolicy">objc_AssociationPolicy</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E7%90%86">关联对象的原理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#block">Block</a>
<ul>
<li><a href="ProgrammingLanguages/OC/OCNote.html#block%E7%9A%84%E6%9C%AC%E8%B4%A8">Block 的本质</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#block%E7%9A%84%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7%E6%9C%BA%E5%88%B6">Block 的变量捕获机制</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#block%E7%B1%BB%E5%9E%8B">Block 类型</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#block%E7%9A%84-copy">Block 的 copy</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84auto%E5%8F%98%E9%87%8F">对象类型的 auto 变量</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#block%E4%BF%AE%E9%A5%B0%E7%AC%A6">__block 修饰符</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#block%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">__block 的内存管理</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E8%A2%ABblock%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B">被 __block 修饰的对象类型</a></li>
</ul>
</li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#runtime">Runtime</a>
<ul>
<li><a href="ProgrammingLanguages/OC/OCNote.html#class%E7%BB%93%E6%9E%84">Class 结构</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98">方法缓存</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#oc%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6">OC 消息机制</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#super%E5%85%B3%E9%94%AE%E5%AD%97"><code>super</code> 关键字</a></li>
</ul>
</li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#runloop">RunLoop</a>
<ul>
<li><a href="ProgrammingLanguages/OC/OCNote.html#runloop%E6%9C%AC%E8%B4%A8">RunLoop 本质</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#runloop%E4%B8%8E%E7%BA%BF%E7%A8%8B">RunLoop 与线程</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#runloop%E7%9A%84%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91">RunLoop 的运行逻辑</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB">线程保活</a></li>
</ul>
</li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a>
<ul>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E5%90%84%E7%A7%8D%E9%98%9F%E5%88%97%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E6%9E%9C">各种队列的执行效果</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E8%AF%B7%E9%97%AE%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">请问下面代码的打印结果是什么？</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5">线程同步</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83">线程同步方案性能比较</a></li>
</ul>
</li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#timer">Timer</a>
<ul>
<li><a href="ProgrammingLanguages/OC/OCNote.html#cadisplaylink%E3%80%81nstimer%E3%80%81dispatch-source-t">CADisplayLink、NSTimer、dispatch_source_t</a></li>
</ul>
</li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">内存管理</a>
<ul>
<li><a href="ProgrammingLanguages/OC/OCNote.html#ios%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">iOS 程序的内存布局</a></li>
<li><a href="ProgrammingLanguages/OC/OCNote.html#tagged-pointer">Tagged Pointer</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="面向对象"><a class="header" href="#面向对象">面向对象</a></h2>
<h3 id="oc---cc"><a class="header" href="#oc---cc">OC -&gt; C/C++</a></h3>
<pre><code class="language-bash">$ clang -rewrite-objc main.m -o main.cpp
// 指定平台和架构。模拟器(i386)、32bit(armv7)、64bit(arm64)
$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp
// cannot create __weak reference in file using manual reference 解决方法：支持 ARC，指定运行时版本
$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-14.0.0 main.m
</code></pre>
<h3 id="一个-nsobject-对象占用多少内存"><a class="header" href="#一个-nsobject-对象占用多少内存">一个 NSObject 对象占用多少内存？</a></h3>
<ul>
<li>系统分配了 16 个字节给 NSObject 对象（通过 <code>malloc_size</code> 函数获得）</li>
<li>但 NSObject 对象内部只用了 8 个字节的空间（64 位下，可以通过 <code>class_getInstanceSize</code> 函数获得）</li>
</ul>
<pre><code class="language-objectivec">// 获取 NSObjcet 类实例对象的成员变量所占用的空间，其实例对象的成员变量只用 isa，所以返回 8
NSLog(@&quot;%zd&quot;, class_getInstanceSize([NSObjcet class]);
// 获取 obj 指针所指向内存的大小，返回 16
NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)obj));
// 编译时，上方两个方法是运行时
NSLog(@&quot;%zd&quot;, sizeof(obj));
</code></pre>
<ul>
<li>结构体内存对齐：最大成员大小的倍数</li>
<li>iOS 内存对齐：16 的倍数</li>
</ul>
<h3 id="对象的-isa-指针指向哪里"><a class="header" href="#对象的-isa-指针指向哪里">对象的 isa 指针指向哪里？</a></h3>
<ul>
<li>instance 对象的指针指向 class 对象</li>
<li>class 对象的指针指向 meta-class 对象</li>
<li>meta-class 对象的指针指向基类的 meta-class 对象、</li>
</ul>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202160957523.png" alt="" /></p>
<h3 id="oc-的类信息存放在哪里"><a class="header" href="#oc-的类信息存放在哪里">OC 的类信息存放在哪里？</a></h3>
<ul>
<li>对象方法、属性、成员变量、协议信息，存放在 class 对象中</li>
<li>类方法存放在 meta-class 对象中</li>
<li>成员变量的具体值，存放在 instance 对象中</li>
</ul>
<hr />
<h2 id="kvo"><a class="header" href="#kvo">KVO</a></h2>
<h3 id="ios-使用什么方式实现一个对象的-kvokvo-的本质是什么"><a class="header" href="#ios-使用什么方式实现一个对象的-kvokvo-的本质是什么">iOS 使用什么方式实现一个对象的 KVO？（KVO 的本质是什么？）</a></h3>
<ul>
<li>利用 Runtime API 动态生成一个子类（NSKVONotifying_SomeClassName），并且让 instance 对象的 isa 指针指向这个全新的子类</li>
<li>当修改 instance 对象的属性时，会调用 Foundation 的 <code>_NSSet(*: Int、Double、Char 等)ValueAndNotify</code> 函数，这个函数的实现：</li>
</ul>
<blockquote>
<ol>
<li><code>willChangeValueForKey:</code></li>
<li>父类原来的 setter</li>
<li><code>didChangeValueForKey:</code></li>
</ol>
</blockquote>
<p><code>didChangeValueForKey:</code> 内部会调用 observer 的 <code>observerValueForKeyPath:ofObject:change:context</code> 方法</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202160959104.png" alt="" /></p>
<h3 id="如何手动触发-kvo"><a class="header" href="#如何手动触发-kvo">如何手动触发 KVO</a></h3>
<ul>
<li>手动调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code></li>
</ul>
<h3 id="直接修改成员变量的值会触发-kvo-么"><a class="header" href="#直接修改成员变量的值会触发-kvo-么">直接修改成员变量的值会触发 KVO 么？</a></h3>
<ul>
<li>不会</li>
</ul>
<hr />
<h2 id="kvc"><a class="header" href="#kvc">KVC</a></h2>
<h3 id="通过-kvc-修改属性会触发-kvo-么"><a class="header" href="#通过-kvc-修改属性会触发-kvo-么">通过 KVC 修改属性会触发 KVO 么？</a></h3>
<ul>
<li>会</li>
</ul>
<h3 id="setvalueforkey-原理"><a class="header" href="#setvalueforkey-原理"><code>setValue:forKey:</code> 原理</a></h3>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161000082.png" alt="" /></p>
<h3 id="valueforkey-原理"><a class="header" href="#valueforkey-原理"><code>valueForKey:</code> 原理</a></h3>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161001048.png" alt="" /></p>
<hr />
<h2 id="category"><a class="header" href="#category">Category</a></h2>
<h3 id="category-的原理"><a class="header" href="#category-的原理">Category 的原理</a></h3>
<ul>
<li>Category 编译之后的底层结构是 <code>struct category_t</code>，里面存储着分类的对象方法、类方法、属性、协议信息</li>
<li>在程序运行时候，runtime 会将 Category 的数据合并到类信息中（类对象、元类对象中）</li>
</ul>
<h3 id="category-和-class-extension-的区别"><a class="header" href="#category-和-class-extension-的区别">Category 和 Class Extension 的区别</a></h3>
<ul>
<li><strong>Class Extension 是在编译时</strong>，它的数据就已经包含在类信息中</li>
<li><strong>Category 是在运行时</strong>，才会将数据合并到类信息中</li>
</ul>
<h3 id="load-方法"><a class="header" href="#load-方法">+load 方法</a></h3>
<ul>
<li>
<p><code>+load</code> 方法会在 runtime 加载<strong>类、分类</strong>时调用</p>
</li>
<li>
<p>每个<strong>类、分类</strong>的 <code>+load</code> 在程序运行时只调用一次</p>
</li>
<li>
<p>调用顺序</p>
<ol>
<li><strong>先调用类的 +load</strong></li>
</ol>
<ul>
<li><strong>按照编译顺序调用</strong>（先编译先调用）</li>
<li>调用子类的 +load 之前会调用父类的 +load</li>
</ul>
<ol start="2">
<li><strong>再调分类的 +load</strong></li>
</ol>
<ul>
<li>按照编译顺序调用（先编译先调用）</li>
</ul>
</li>
<li>
<p><strong>+load 方法是根据方法地址直接调用，并不是经过 objc_msgSend 函数调用</strong></p>
</li>
</ul>
<h3 id="initialize-方法"><a class="header" href="#initialize-方法">+initialize 方法</a></h3>
<ul>
<li>+initialize 方法会在类第一次收到消息时调用</li>
<li>调用顺序
<ul>
<li>先调用父类的 +initialize，再调用子类的 +initialize （先初始化父类，再初始化子类，每个类只初始化一次）</li>
</ul>
</li>
<li><strong>如果子类没有实现 +initialize，会调用父类的 +initialize （所以父类的 +initialize 可能会被调用多次）</strong></li>
<li><strong>如果分类实现了 +initialize，就覆盖类本身的 +initialize</strong></li>
</ul>
<h3 id="给-category-添加成员变量"><a class="header" href="#给-category-添加成员变量">给 Category 添加成员变量</a></h3>
<ul>
<li>不能直接给 Category 添加成员变量，但可以通过 <strong>关联对象</strong> 间接实现</li>
</ul>
<h4 id="关联对象"><a class="header" href="#关联对象">关联对象</a></h4>
<ul>
<li>添加关联对象</li>
</ul>
<p><code>void objc_setAssociatedObject(id object, const void * key, id value, objc_AssociationPolicy policy)</code></p>
<ul>
<li>获取关联对象</li>
</ul>
<p><code>id objc_getAssociatedObject(id object, const void * key)</code></p>
<ul>
<li>移除所有关联对象</li>
</ul>
<p><code>void objc_removeAssociatedObjects(id object)</code></p>
<h4 id="关联对象的-key-的常见用法"><a class="header" href="#关联对象的-key-的常见用法">关联对象的 key 的常见用法</a></h4>
<pre><code class="language-objectivec">static void *MyKey = &amp;MyKey;
objc_setAssociatedObject(obj, MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)
objc_getAssociatedObject(obj, MyKey)

static char MyKey;
objc_setAssociatedObject(obj, &amp;MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)
objc_getAssociatedObject(obj, &amp;MyKey)

// 使用属性名作为key
objc_setAssociatedObject(obj, @&quot;property&quot;, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
objc_getAssociatedObject(obj, @&quot;property&quot;);

// 使用get方法的@selecor作为key
objc_setAssociatedObject(obj, @selector(getter), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)
objc_getAssociatedObject(obj, @selector(getter))
</code></pre>
<h4 id="objc_associationpolicy"><a class="header" href="#objc_associationpolicy">objc_AssociationPolicy</a></h4>
<table><thead><tr><th>objc_AssociationPolicy</th><th>对应的修饰符</th></tr></thead><tbody>
<tr><td>OBJC_ASSOCIATION_ASSIGN</td><td>assign</td></tr>
<tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td>strong, nonatomic</td></tr>
<tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td>copy, nonatomic</td></tr>
<tr><td>OBJC_ASSOCIATION_RETAIN</td><td>strong, atomic</td></tr>
<tr><td>OBJC_ASSOCIATION_COPY</td><td>copy, atomic</td></tr>
</tbody></table>
<h4 id="关联对象的原理"><a class="header" href="#关联对象的原理">关联对象的原理</a></h4>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161003141.png" alt="" /></p>
<hr />
<h2 id="block"><a class="header" href="#block">Block</a></h2>
<h3 id="block-的本质"><a class="header" href="#block-的本质">Block 的本质</a></h3>
<ul>
<li>block 本质上也是一个 OC 对象</li>
<li>block 是封装了函数调用和函数调用环境的 OC 对象</li>
</ul>
<h3 id="block-的变量捕获机制"><a class="header" href="#block-的变量捕获机制">Block 的变量捕获机制</a></h3>
<table><thead><tr><th>变量类型</th><th style="text-align: center">捕获到 block 内部</th><th>访问方式</th></tr></thead><tbody>
<tr><td>局部变量 auto</td><td style="text-align: center">✅</td><td>值传递</td></tr>
<tr><td>局部变量 static</td><td style="text-align: center">✅</td><td>指针传递</td></tr>
<tr><td>全局变量</td><td style="text-align: center">❌</td><td>直接访问</td></tr>
</tbody></table>
<h3 id="block-类型"><a class="header" href="#block-类型">Block 类型</a></h3>
<table><thead><tr><th style="text-align: center">block 类型</th><th style="text-align: center">环境</th><th style="text-align: center">内存分配</th><th>复制效果</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>__NSGlobalBlock__</code></td><td style="text-align: center">没有访问 auto 变量</td><td style="text-align: center">数据区（.data 区）</td><td>什么也不做</td></tr>
<tr><td style="text-align: center"><code>__NSStackBlock__</code></td><td style="text-align: center">访问了 auto 变量</td><td style="text-align: center">栈</td><td>从栈复制到堆</td></tr>
<tr><td style="text-align: center"><code>__NSMallocBlock__</code></td><td style="text-align: center"><code>__NSStackBlock__</code> 调用了 copy</td><td style="text-align: center">堆</td><td>引用计数增加</td></tr>
</tbody></table>
<blockquote>
<p>程序区（.text 区） —— 低地址<br />
数据区（.data 区）：全局变量<br />
堆：动态分配<br />
栈 —— 高地址</p>
</blockquote>
<h3 id="block-的-copy"><a class="header" href="#block-的-copy">Block 的 copy</a></h3>
<p>在 ARC 环境下，以下情况编译器会自动将栈上的 block 复制到堆上：</p>
<ul>
<li>block 作为返回值时</li>
<li>将 block 赋值给 __strong 指针时</li>
<li>block 作为 Cocoa API 中方法名含有 <code>usingBlock</code> 的方法参数时</li>
<li>block 作为 GCD API 的方法参数时</li>
</ul>
<h3 id="对象类型的-auto-变量"><a class="header" href="#对象类型的-auto-变量">对象类型的 auto 变量</a></h3>
<p>当 block 访问了对象类型的 auto 变量时：</p>
<ul>
<li>如果 block 在栈上，将不会对 auto 变量产生强引用</li>
<li>如果 block 被拷贝到堆上
<ul>
<li>会调用 block 内部的 copy 函数</li>
<li>copy 函数内部会调用 <code>_Block_object_assign</code> 函数</li>
<li><code>_Block_object_assign</code> 函数会根据 auto 变量的修饰符（<code>__strong</code>, <code>__weak</code>, <code>__unsafe_unretained</code>）做出相应的操作，形成强引用或弱引用</li>
</ul>
</li>
<li>如果 block 从堆上移除
<ul>
<li>会调用 block 内部的 dispose 函数</li>
<li>dispose 函数内部会调用 <code>_Block_object_dispose</code> 函数</li>
<li><code>_Block_object_dispose</code> 函数会自动释放引用的 auto 变量（release）</li>
</ul>
</li>
</ul>
<h3 id="__block-修饰符"><a class="header" href="#__block-修饰符">__block 修饰符</a></h3>
<ul>
<li><code>__block</code> 可以解决 block 内部无法修改 auto 变量值的问题</li>
<li><code>__block</code> 不能修饰全局变量、静态变量</li>
<li>编译器会将 <code>__block</code> 修饰的变量包装成一个对象</li>
</ul>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161004760.png" alt="" />
<img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161004077.png" alt="" /></p>
<h3 id="__block-的内存管理"><a class="header" href="#__block-的内存管理">__block 的内存管理</a></h3>
<ul>
<li>当 block 在栈上时，并不会对 __block 变量产生强引用</li>
<li>当 block 被 copy 到堆时
<ul>
<li>会调用 block 内部的 copy 函数</li>
<li>copy 函数内部会调用 <code>_Block_object_assign</code> 函数</li>
<li><code>_Block_object_assign</code> 函数会对 __block 变量形成强引用（retain）</li>
</ul>
</li>
<li>当 block 从堆中移除时
<ul>
<li>会调用 block 内部的 dispose 函数</li>
<li>dispose 函数内部会调用 <code>_Block_object_dispose</code> 函数</li>
<li><code>_Block_object_dispose</code> 函数会自动释放引用的 __block 变量（release）</li>
</ul>
</li>
</ul>
<h3 id="被-__block-修饰的对象类型"><a class="header" href="#被-__block-修饰的对象类型">被 __block 修饰的对象类型</a></h3>
<ul>
<li>当 __block 变量在栈上时，不会对指向的对象产生强引用</li>
<li>当 __block 变量被 copy 到堆时
<ul>
<li>会调用 __block 变量内部的 copy 函数</li>
<li>copy 函数内部会调用 <code>_Block_object_assign</code>  函数</li>
<li><code>_Block_object_assign</code> 函数会根据所指向对象的修饰符（<code>__strong</code>、<code>__weak</code>、<code>__unsafe_unretained</code>）做出相应的操作，形成强引用（retain）或者弱引用（注意：这里仅限于 ARC 时会 retain，MRC 时不会 retain）</li>
</ul>
</li>
<li>如果 __block 变量从堆上移除
<ul>
<li>会调用 __block 变量内部的 dispose 函数</li>
<li>dispose 函数内部会调用 <code>_Block_object_dispose</code> 函数</li>
<li><code>_Block_object_dispose</code> 函数会自动释放指向的对象（release）</li>
</ul>
</li>
</ul>
<hr />
<h2 id="runtime"><a class="header" href="#runtime">Runtime</a></h2>
<h3 id="class-结构"><a class="header" href="#class-结构">Class 结构</a></h3>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161005645.png" alt="" /></p>
<h3 id="方法缓存"><a class="header" href="#方法缓存">方法缓存</a></h3>
<p>Class 内部结构中有个方法缓存（cache_t），用**散列表（哈希表）**来缓存曾经调用过的方法，可以提高方法的查找速度</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161005849.png" alt="" /></p>
<h3 id="oc-消息机制"><a class="header" href="#oc-消息机制">OC 消息机制</a></h3>
<p>OC 中的方法调用，都是转换为 <code>objc_msgSend</code> 函数的调用，<code>objc_msgSend</code> 的执行流程：</p>
<ol>
<li>
<p>消息发送</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161006685.png" alt="" /></p>
</li>
<li>
<p>动态方法解析</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161006903.png" alt="" /></p>
</li>
<li>
<p>消息转发</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161006143.png" alt="" /></p>
</li>
</ol>
<h3 id="super-关键字"><a class="header" href="#super-关键字"><code>super</code> 关键字</a></h3>
<p>super 调用，底层会转换为 <code>objc_msgSendSuper2</code> 函数的调用，接收 2 个参数：</p>
<ol>
<li>struct objc_super2</li>
<li>SEL</li>
</ol>
<pre><code class="language-objectivec">struct objc_super2 {
  id receiver; // 消息接收者
  Class current_class; // receiver 的 Class 对象
}
</code></pre>
<ul>
<li><strong>消息接收着仍然是子类对象</strong></li>
<li><strong>从父类开始查找方法的实现</strong></li>
</ul>
<hr />
<h2 id="runloop"><a class="header" href="#runloop">RunLoop</a></h2>
<h3 id="runloop-本质"><a class="header" href="#runloop-本质">RunLoop 本质</a></h3>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161007756.png" alt="" /></p>
<p><strong>CFRunLoopModeRef</strong></p>
<ul>
<li>CFRunLoopModeRef  代表 RunLoop 的运行模式</li>
<li>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source0/Source1/Timer/Observer</li>
<li>RunLoop 启动时只能选择其中一个 Mode，作为 currentMode</li>
<li><strong>如果需要切换 Mode，只能退出当前 Loop，再重新选择一个 Mode 进入</strong>
<ul>
<li>不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响</li>
</ul>
</li>
<li><strong>如果 Mode 里没有任何 Source0/Source1/Timer/Observer，RunLoop 会立马退出</strong></li>
</ul>
<ol>
<li><strong>Source0</strong></li>
</ol>
<ul>
<li>触摸事件处理</li>
<li><code>performSelector:onThread:</code></li>
</ul>
<ol start="2">
<li><strong>Source1</strong></li>
</ol>
<ul>
<li>基于 Port 的线程间通信</li>
<li>系统事件捕捉</li>
</ul>
<ol start="3">
<li><strong>Timers</strong></li>
</ol>
<ul>
<li>NSTimer</li>
<li><code>performSelector:withObject:afterDelay:</code></li>
</ul>
<ol start="4">
<li><strong>Observers</strong></li>
</ol>
<ul>
<li>用于监听 RunLoop 的状态</li>
<li>UI 刷新（BeforeWaiting）</li>
<li>Autorelease pool（BeforeWaiting）</li>
</ul>
<h3 id="runloop-与线程"><a class="header" href="#runloop-与线程">RunLoop 与线程</a></h3>
<ul>
<li>每条线程都有唯一的一个与之对应的 RunLoop 对象</li>
<li>RunLoop 保存在一个全局的 Dictionary 里，线程作为 key，RunLoop 作为 value</li>
<li>线程刚创建时并没有 RunLoop 对象，<strong>RunLoop 会在第一次获取它时创建</strong></li>
<li>RunLoop 会在线程结束时销毁</li>
<li>主线程的 RunLoop 已经自动获取（创建），<strong>子线程默认没有开启 RunLoop</strong></li>
</ul>
<h3 id="runloop-的运行逻辑"><a class="header" href="#runloop-的运行逻辑">RunLoop 的运行逻辑</a></h3>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161008263.png" alt="" /></p>
<h3 id="线程保活"><a class="header" href="#线程保活">线程保活</a></h3>
<ul>
<li>NSRunLoop 的 <code>run</code> 方法是无法停止的</li>
</ul>
<blockquote>
<p>If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking  <code>runMode:beforeDate:</code>. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</p>
</blockquote>
<hr />
<h2 id="多线程"><a class="header" href="#多线程">多线程</a></h2>
<h3 id="各种队列的执行效果"><a class="header" href="#各种队列的执行效果">各种队列的执行效果</a></h3>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161008460.png" alt="" /></p>
<h3 id="请问下面代码的打印结果是什么"><a class="header" href="#请问下面代码的打印结果是什么">请问下面代码的打印结果是什么？</a></h3>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161008254.png" alt="" /></p>
<ul>
<li>打印结果是：1、3</li>
<li>因为 <code>performSelector:withObject:afterDelay:</code> 的本质是往 Runloop 中添加定时器，而子线程默认没有启动 Runloop</li>
</ul>
<h3 id="线程同步"><a class="header" href="#线程同步">线程同步</a></h3>
<ol>
<li><strong>OSSPinLock</strong></li>
</ol>
<ul>
<li>
<p><code>OSSpinLock</code> 叫做<strong>自旋锁，等待锁的线程会处于忙等（busy-wait）状态</strong>，一直占用着 CPU 资源</p>
</li>
<li>
<p><strong>目前已不再安全，可能会出现优先级反转问题</strong></p>
</li>
<li>
<p>如果等待锁的线程优先级较高，它会一直占用着 CPU 资源，优先级低的线程就无法释放锁</p>
</li>
<li>
<p>需要导入头文件 <code>#import &lt;libkern/OSAtomic.h&gt;</code></p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161009301.png" alt="" /></p>
</li>
</ul>
<ol start="2">
<li><strong>os_unfair_lock</strong></li>
</ol>
<ul>
<li>
<p>互斥锁</p>
</li>
<li>
<p><code>os_unfair_lock</code> 用于取代不安全的 <code>OSSpinLock</code> ，从 iOS 10 开始才支持</p>
</li>
<li>
<p>等待 <code>os_unfair_lock</code> 锁的线程会处于休眠状态，并非忙等</p>
</li>
<li>
<p>需要导入头文件 <code>#import &lt;os/lock.h&gt;</code></p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161009209.png" alt="" /></p>
</li>
</ul>
<ol start="3">
<li><strong>pthread_mutex</strong> </li>
</ol>
<ul>
<li>
<p><code>mutex</code> 叫做”互斥锁”，等待锁的线程会处于休眠状态</p>
</li>
<li>
<p>需要导入头文件 <code>#import &lt;pthread.h&gt;</code></p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161009346.png" alt="" /></p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161009567.png" alt="" /></p>
</li>
<li>
<p><strong>pthread_mutex – 递归锁</strong> </p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161010697.png" alt="" /></p>
</li>
<li>
<p><strong>pthread_mutex – 条件</strong> </p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161010454.png" alt="" /></p>
</li>
</ul>
<ol start="4">
<li><strong>NSLock、NSRecursiveLock</strong> </li>
</ol>
<ul>
<li>
<p><code>NSLock</code> 是对 <code>mutex</code> 普通锁的封装</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161010366.png" alt="" /></p>
</li>
<li>
<p><code>NSRecursiveLock</code> 是对 mutex 递归锁的封装，API 跟 NSLock 基本一致</p>
</li>
</ul>
<ol start="5">
<li><strong>NSCondition</strong> </li>
</ol>
<ul>
<li>
<p><code>NSCondition</code> 是对 mutex 和 cond 的封装</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161011849.png" alt="" /></p>
</li>
</ul>
<ol start="6">
<li><strong>NSConditionLock</strong> </li>
</ol>
<ul>
<li>
<p><code>NSConditionLock</code> 是对 <code>NSCondition</code> 的进一步封装，可以设置具体的条件值</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161011803.png" alt="" /></p>
</li>
</ul>
<ol start="7">
<li><strong>dispatch_semaphore</strong> </li>
</ol>
<ul>
<li>
<p>semaphore 叫做”信号量”</p>
</li>
<li>
<p>信号量的初始值，可以用来控制线程并发访问的最大数量</p>
</li>
<li>
<p>信号量的初始值为 1，代表同时只允许 1 条线程访问资源，保证线程同步</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161011979.png" alt="" /></p>
</li>
</ul>
<ol start="8">
<li><strong>dispatch_queue</strong> </li>
</ol>
<ul>
<li>
<p>直接使用 GCD 的串行队列，也是可以实现线程同步的</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161012258.png" alt="" /></p>
</li>
</ul>
<ol start="9">
<li><strong>@synchronized</strong> </li>
</ol>
<ul>
<li><code>@synchronized</code> 是对 mutex 递归锁的封装</li>
<li>源码查看：objc4 中的 <code>objc-sync.mm</code> 文件</li>
<li><code>@synchronized(obj)</code> 内部会生成 obj 对应的递归锁，然后进行加锁、解锁操作</li>
</ul>
<ol start="10">
<li><strong>pthread_rwlock</strong>  读写锁</li>
</ol>
<ul>
<li>
<p>等待锁的线程会进入休眠</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161012025.png" alt="" /></p>
</li>
</ul>
<ol start="11">
<li><strong>dispatch_barrier_async</strong> </li>
</ol>
<ul>
<li>
<p><strong>这个函数传入的并发队列必须是自己通过 dispatch_queue_cretate 创建的</strong></p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161012194.png" alt="" /></p>
</li>
<li>
<p><strong>iOS 中的读写安全方案 10、11</strong></p>
</li>
</ul>
<h3 id="线程同步方案性能比较"><a class="header" href="#线程同步方案性能比较">线程同步方案性能比较</a></h3>
<ul>
<li>性能从高到低排序</li>
</ul>
<blockquote>
<p>os_unfair_lock<br />
OSSpinLock<br />
dispatch_semaphore<br />
pthread_mutex<br />
dispatch_queue(DISPATCH_QUEUE_SERIAL)<br />
NSLock<br />
NSCondition<br />
pthread_mutex(recursive)<br />
NSRecursiveLock<br />
NSConditionLock<br />
@synchronized</p>
</blockquote>
<hr />
<h2 id="timer"><a class="header" href="#timer">Timer</a></h2>
<h3 id="cadisplaylinknstimerdispatch_source_t"><a class="header" href="#cadisplaylinknstimerdispatch_source_t">CADisplayLink、NSTimer、dispatch_source_t</a></h3>
<ul>
<li>
<p><code>CADisplayLink</code>、<code>NSTimer</code> 会对 target 产生强引用，如果 target 又对它们产生强引用，那么就会引发循环引用，解决方案：</p>
<ol>
<li>使用 block</li>
</ol>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161013253.png" alt="" /></p>
<ol start="2">
<li>使用 NSProxy</li>
</ol>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161013164.png" alt="" /></p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161013391.png" alt="" /></p>
</li>
<li>
<p><code>NSTimer</code> 依赖于 RunLoop，如果 RunLoop 的任务过于繁重，可能会导致 NSTimer 不准时，而 GCD 的定时器会更加准时</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161014689.png" alt="" /></p>
</li>
</ul>
<hr />
<h2 id="内存管理"><a class="header" href="#内存管理">内存管理</a></h2>
<h3 id="ios-程序的内存布局"><a class="header" href="#ios-程序的内存布局">iOS 程序的内存布局</a></h3>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161014281.png" alt="" /></p>
<h3 id="tagged-pointer"><a class="header" href="#tagged-pointer">Tagged Pointer</a></h3>
<ul>
<li>从 64bit 开始，iOS 引入了 Tagged Pointer 技术，用于优化 NSNumber、NSDate、NSString 等小对象的存储</li>
<li>在没有使用 Tagged Pointer 之前， NSNumber 等对象需要动态分配内存、维护引用计数等，NSNumber 指针存储的是堆中 NSNumber 对象的地址值</li>
<li>使用 Tagged Pointer 之后，NSNumber 指针里面存储的数据变成了：Tag + Data，也就是<strong>将数据直接存储在了指针中</strong></li>
<li>当指针不够存储数据时，才会使用动态分配内存的方式来存储数据</li>
<li><code>objc_msgSend</code> 能识别 Tagged Pointer，比如 NSNumber 的 <code>intValue</code> 方法，直接从指针提取数据，节省了以前的调用开销</li>
<li>如何判断一个指针是否为 Tagged Pointer？
<ul>
<li>iOS 平台，最高有效位是 1（第 64bit）</li>
<li>Mac 平台，最低有效位是 1</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计"><a class="header" href="#设计">设计</a></h1>
<blockquote>
<p>哪怕懂一点设计知识，看到的东西也和别人有本质的不同。</p>
</blockquote>
<blockquote>
<p>Good artists copy. Great artists steal. —— Pablo Picasso</p>
</blockquote>
<blockquote>
<p>生活中任何微小的问题都值得去思考，身边的一切都可能是灵感的来源。</p>
</blockquote>
<h2 id="教程"><a class="header" href="#教程">教程</a></h2>
<ul>
<li><a href="https://boxueio.com/series/color-basics/">Color basics</a></li>
<li><a href="https://boxueio.com/series/sketch-basics/">Sketch basics</a></li>
<li><a href="https://sspai.com/series/67/list/">比身边人多懂一点设计</a></li>
</ul>
<h2 id="设计软件及资源"><a class="header" href="#设计软件及资源">设计软件及资源</a></h2>
<ul>
<li><a href="Design/./Sketch.html">Sketch</a></li>
<li><a href="Design/./Figma.html">Figma</a></li>
</ul>
<h2 id="icons"><a class="header" href="#icons">Icons</a></h2>
<ul>
<li><a href="https://github.com/akveo/eva-icons/">Eva Icons</a></li>
<li><a href="https://github.com/twbs/icons/">Bootstrap Icons</a></li>
</ul>
<h2 id="字体"><a class="header" href="#字体">字体</a></h2>
<ul>
<li><a href="https://fonts.google.com/">https://fonts.google.com/</a></li>
<li><a href="https://source.typekit.com/source-han-serif/tw/">思源宋体</a></li>
<li><a href="http://jikasei.me/font/genjyuu/">思源柔黑</a></li>
<li><a href="http://jikasei.me/font/genshin/">思源真黑</a></li>
<li><a href="http://www.foundertype.com/index.php/FontInfo/index/id/402.html/">方正屏显雅宋</a></li>
<li><a href="https://3type.cn/fonts/dinkie_bitmap/">丁卯点阵体</a></li>
<li><a href="http://tsanger.cn/">苍耳字库</a></li>
<li><a href="https://www.luckytype.com/">喜鹊造字</a></li>
</ul>
<h2 id="颜色"><a class="header" href="#颜色">颜色</a></h2>
<ul>
<li><a href="http://color.adobe.com/">Adobe Color CC</a></li>
<li><a href="https://www.webdesignrankings.com/resources/lolcolors/">LOL Colors</a> - Curated color palette inspiration.</li>
<li><a href="https://flatuicolors.com/">Flat UI Colors 2</a></li>
<li><a href="http://www.flatuicolorpicker.com/">Flat UI Color Picker</a></li>
<li><a href="http://zhongguose.com/">中国传统颜色</a></li>
<li><a href="https://nipponcolors.com/">日本传统颜色</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E4%BC%A0%E7%BB%9F%E8%89%B2%E7%B3%BB/">日本传统色系</a> - 维基百科</li>
<li><a href="https://uigradients.com/">渐变色</a></li>
<li><a href="https://www.colorspire.com/">Colorspire</a> - Create Color Schemes, Test Color Combinations.</li>
</ul>
<h2 id="-链接"><a class="header" href="#-链接">🔗 链接</a></h2>
<ul>
<li><a href="https://dribbble.com/">Dribbble</a>
<ul>
<li><a href="https://dribbble.com/google/">Google</a></li>
<li><a href="https://dribbble.com/DesigningUber/">Uber</a></li>
<li><a href="https://dribbble.com/Facebook/">Facebook</a></li>
<li><a href="https://dribbble.com/ideo/">Ideo</a></li>
<li><a href="https://dribbble.com/iconfactory/">IconFactory</a></li>
<li><a href="https://dribbble.com/hi09ui/">09UI</a></li>
<li><a href="https://dribbble.com/ueno/">Ueno</a></li>
<li><a href="https://dribbble.com/RDDteam/">Radesign</a></li>
<li><a href="https://dribbble.com/javiperez/">Javi Pérez</a></li>
<li><a href="https://dribbble.com/jonyfang/">Jony Fang</a></li>
<li><a href="https://dribbble.com/Madebyelvis/">MBE</a></li>
<li><a href="https://dribbble.com/aureliensalomon/">Aurélien Salomon</a></li>
<li><a href="https://dribbble.com/bwv1068/">Musical Offering</a></li>
<li><a href="https://dribbble.com/glebich/">Gleb Kuznetsov</a></li>
<li><a href="https://dribbble.com/sandor/">Sandor</a></li>
</ul>
</li>
<li><a href="https://collectui.com/">https://collectui.com/</a></li>
<li><a href="https://www.behance.net/">Behance</a></li>
<li><a href="https://www.pinterest.com/">Pinterest</a></li>
<li><a href="https://www.deviantart.com/">DeviantArt</a> - 一个汇集建筑、艺术、家居、科技、旅行等各个设计领域的新闻网站t</li>
<li><a href="https://www.pentagram.com/">Pentagram</a> - <a href="https://www.apple.com/newsroom/2016/11/designed-by-apple-in-california-chronicles-20-years-of-apple-design/">《Designed by Apple in California》</a>的设计者，三星 Galaxy S8 的用户界面、DC 漫画的品牌形象更新</li>
<li><a href="https://ueno.co/">ueno</a> - <a href="https://www.clearmotion.com/">ClearMotion</a> 的官网和 <a href="https://slack.com/">Slack</a> 官网设计都是出自他们之手</li>
<li><a href="https://dinehq.com/">Dine</a> - 设计过 <a href="https://theinitium.com/">端传媒</a> 和 <a href="http://www.qdaily.com/">好奇心日报</a> 的网页端和移动端</li>
<li><a href="https://anyway.fm/">Anyway.fm</a> - 一个由 JJ Ying 和 Leon Gao 组成的设计类播客栏目</li>
<li><a href="http://www.voicer.me/">VOICER</a></li>
<li><a href="https://500px.com/">500px</a></li>
<li><a href="https://www.flickr.com/">Flickr</a></li>
<li><a href="https://unsplash.com/">Unsplash</a></li>
<li><a href="https://lfi-online.de/ceemes/en/gallery/">LFI (Leica Fotografie International)</a></li>
<li><a href="https://1x.com/">1x</a></li>
<li><a href="https://book.douban.com/subject/1941558/">设计中的设计</a></li>
<li><a href="https://dareful.com/">https://dareful.com/</a></li>
<li><a href="https://nodesign.dev/">https://nodesign.dev/</a></li>
<li><a href="http://www.asciiworld.com/">http://www.asciiworld.com/</a> - Pictures of Ascii Art!</li>
<li><a href="http://chuangzaoshi.com/">创造师导航</a> - 设计资源合集</li>
<li><a href="https://www.maliquankai.com/">码力全开</a> - 设计资源合集</li>
<li><a href="https://backpack.github.io/">Backpack</a> - 设计资源合集</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sketch-及资源"><a class="header" href="#sketch-及资源">Sketch 及资源</a></h1>
<blockquote>
<p>Sketch 是由荷兰公司 Sketch BV 开发 macOS 专用的矢量图形编辑器。它于 2010 年 9 月 7 日首次发布并于 2012 年获得了苹果设计大奖。其主要用于网站和移动应用程序的用户界面和用户体验设计，Sketch 具有原型设计和协作的功能。仅适用于 macOS 的第三方软件和第三方工具上查看 Sketch 原型。 —— 维基百科</p>
</blockquote>
<ul>
<li><a href="https://www.sketch.com">Sketch</a></li>
</ul>
<h2 id="-链接-1"><a class="header" href="#-链接-1">🔗 链接</a></h2>
<ul>
<li><a href="https://www.sketchappsources.com/">https://www.sketchappsources.com/</a></li>
<li><a href="https://interfacer.xyz/">https://interfacer.xyz/</a></li>
<li><a href="https://iosdesignkit.io/">https://iosdesignkit.io/</a></li>
<li><a href="https://animaapp.github.io/sketch-web-viewer/">Sketch Web Viewer</a></li>
<li><a href="https://github.com/allenwong/MakeIconsWithSketch/">Make Icons With Sketch</a></li>
<li><a href="https://developer.apple.com/design/resources/">Apple Design Resources</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="figma-及资源"><a class="header" href="#figma-及资源">Figma 及资源</a></h1>
<blockquote>
<p>Figma 是一个向量图形编辑器和原型设计工具，主要基於网页 ，透过 macOS 和 Windows 的桌面应用程式可启用额外的离线功能。適用於 Android 和 iOS 的配套程式称为 Figma Mirror，可以在行动装置上查看 Figma 原型。Figma 的功能集著重於 用户界面设计及用户体验设计中的使用，並强调即时协作。 —— 维基百科</p>
</blockquote>
<ul>
<li><a href="https://www.figma.com">Figma</a></li>
</ul>
<h2 id="-链接-2"><a class="header" href="#-链接-2">🔗 链接</a></h2>
<ul>
<li><a href="https://www.figma.com/community/explore/">Figma Community</a></li>
<li><a href="https://www.figma.com/community/file/865778936829514703/">中国银行矢量标志合集</a></li>
<li><a href="https://www.figma.com/community/file/932547561953107053/">中国传统色：故宫里的色彩美学</a></li>
<li><a href="https://www.figma.com/community/file/916515339708288305/">中国大学矢量校徽合集</a></li>
<li><a href="https://www.figma.com/community/file/873499056700046462/">5×7 LED Digital Letters</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="故事"><a class="header" href="#故事">故事</a></h1>
<blockquote>
<p>倾听别人的故事，让人生存下去的不是食物，而是故事。</p>
</blockquote>
<h2 id="链接-4"><a class="header" href="#链接-4">链接</a></h2>
<ul>
<li><a href="http://61.life/">61’s life</a> - 谜底科技创始人</li>
<li><a href="https://atjason.com/">Jason - 每天写一点</a> - Klib、iPic、iText、iHosts、iPaste、iTimer 作者</li>
<li><a href="https://www.himself65.com/blog/">Himself65</a> - An Iowa state university freshman, member of node.js &amp; hexo.js.</li>
<li><a href="https://tt.daibor.cn/">听听的叨叨</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
