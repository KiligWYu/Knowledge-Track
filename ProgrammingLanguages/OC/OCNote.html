<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Objective-C 底层学习笔记 - Kilig 的第二大脑</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../Introduction.html"><strong aria-hidden="true">1.</strong> 首页</a></li><li class="chapter-item expanded "><a href="../../meta/meta.html"><strong aria-hidden="true">2.</strong> 知识体系单元</a></li><li class="chapter-item expanded "><a href="../../macOS/macOS.html"><strong aria-hidden="true">3.</strong> macOS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../macOS/cli/cli.html"><strong aria-hidden="true">3.1.</strong> 命令行</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../macOS/cli/ohmyzsh.html"><strong aria-hidden="true">3.1.1.</strong> Oh My Zsh</a></li><li class="chapter-item expanded "><a href="../../macOS/cli/homebrew.html"><strong aria-hidden="true">3.1.2.</strong> Homebrew</a></li><li class="chapter-item expanded "><a href="../../macOS/cli/rbenv.html"><strong aria-hidden="true">3.1.3.</strong> rbenv</a></li></ol></li><li class="chapter-item expanded "><a href="../../macOS/apps.html"><strong aria-hidden="true">3.2.</strong> macOS 应用</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 计算机科学</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../ProgrammingLanguages/ProgrammingLanguages.html"><strong aria-hidden="true">4.1.</strong> 编程语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../ProgrammingLanguages/Swift/Swift.html"><strong aria-hidden="true">4.1.1.</strong> Swift</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../ProgrammingLanguages/Swift/AdvancedSwift.html"><strong aria-hidden="true">4.1.1.1.</strong> Swift 进阶</a></li></ol></li><li class="chapter-item expanded "><a href="../../ProgrammingLanguages/OC/OC.html"><strong aria-hidden="true">4.1.2.</strong> Objective-C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../ProgrammingLanguages/OC/OCNote.html" class="active"><strong aria-hidden="true">4.1.2.1.</strong> Objective-C 底层学习笔记</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../Design/Design.html"><strong aria-hidden="true">5.</strong> 设计</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Design/Sketch.html"><strong aria-hidden="true">5.1.</strong> Sketch</a></li><li class="chapter-item expanded "><a href="../../Design/Figma.html"><strong aria-hidden="true">5.2.</strong> Figma</a></li></ol></li><li class="chapter-item expanded "><a href="../../Stories/Stories.html"><strong aria-hidden="true">6.</strong> 故事</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kilig 的第二大脑</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/KiligWYu/Knowledge-Track" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="oc-底层学习笔记"><a class="header" href="#oc-底层学习笔记">OC 底层学习笔记</a></h1>
<ul>
<li><a href="#oc%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">OC 底层学习笔记</a>
<ul>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a>
<ul>
<li><a href="#oc-cc">OC -&gt; C/C++</a></li>
<li><a href="#%E4%B8%80%E4%B8%AAnsobject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98%EF%BC%9F">一个 NSObject 对象占用多少内存？</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84isa%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E5%93%AA%E9%87%8C%EF%BC%9F">对象的 isa 指针指向哪里？</a></li>
<li><a href="#oc%E7%9A%84%E7%B1%BB%E4%BF%A1%E6%81%AF%E5%AD%98%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F">OC 的类信息存放在哪里？</a></li>
</ul>
</li>
<li><a href="#kvo">KVO</a>
<ul>
<li><a href="#ios%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84-kvo%EF%BC%9F%EF%BC%88kvo%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%89">iOS 使用什么方式实现一个对象的 KVO？（KVO 的本质是什么？）</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91kvo">如何手动触发 KVO</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%E4%BC%9A%E8%A7%A6%E5%8F%91kvo%E4%B9%88%EF%BC%9F">直接修改成员变量的值会触发 KVO 么？</a></li>
</ul>
</li>
<li><a href="#kvc">KVC</a>
<ul>
<li><a href="#%E9%80%9A%E8%BF%87kvc%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7%E4%BC%9A%E8%A7%A6%E5%8F%91-kvo%E4%B9%88%EF%BC%9F">通过 KVC 修改属性会触发 KVO 么？</a></li>
<li><a href="#setvalue-forkey%E5%8E%9F%E7%90%86"><code>setValue:forKey:</code> 原理</a></li>
<li><a href="#valueforkey%E5%8E%9F%E7%90%86"><code>valueForKey:</code> 原理</a></li>
</ul>
</li>
<li><a href="#category">Category</a>
<ul>
<li><a href="#category%E7%9A%84%E5%8E%9F%E7%90%86">Category 的原理</a></li>
<li><a href="#category%E5%92%8C-class-extension%E7%9A%84%E5%8C%BA%E5%88%AB">Category 和 Class Extension 的区别</a></li>
<li><a href="#load%E6%96%B9%E6%B3%95">+load 方法</a></li>
<li><a href="#initialize%E6%96%B9%E6%B3%95">+initialize 方法</a></li>
<li><a href="#%E7%BB%99category%E6%B7%BB%E5%8A%A0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">给 Category 添加成员变量</a>
<ul>
<li><a href="#%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1">关联对象</a></li>
<li><a href="#%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E7%9A%84key%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95">关联对象的 key 的常见用法</a></li>
<li><a href="#objc-associationpolicy">objc_AssociationPolicy</a></li>
<li><a href="#%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E7%90%86">关联对象的原理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#block">Block</a>
<ul>
<li><a href="#block%E7%9A%84%E6%9C%AC%E8%B4%A8">Block 的本质</a></li>
<li><a href="#block%E7%9A%84%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7%E6%9C%BA%E5%88%B6">Block 的变量捕获机制</a></li>
<li><a href="#block%E7%B1%BB%E5%9E%8B">Block 类型</a></li>
<li><a href="#block%E7%9A%84-copy">Block 的 copy</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84auto%E5%8F%98%E9%87%8F">对象类型的 auto 变量</a></li>
<li><a href="#block%E4%BF%AE%E9%A5%B0%E7%AC%A6">__block 修饰符</a></li>
<li><a href="#block%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">__block 的内存管理</a></li>
<li><a href="#%E8%A2%ABblock%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B">被 __block 修饰的对象类型</a></li>
</ul>
</li>
<li><a href="#runtime">Runtime</a>
<ul>
<li><a href="#class%E7%BB%93%E6%9E%84">Class 结构</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98">方法缓存</a></li>
<li><a href="#oc%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6">OC 消息机制</a></li>
<li><a href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><code>super</code> 关键字</a></li>
</ul>
</li>
<li><a href="#runloop">RunLoop</a>
<ul>
<li><a href="#runloop%E6%9C%AC%E8%B4%A8">RunLoop 本质</a></li>
<li><a href="#runloop%E4%B8%8E%E7%BA%BF%E7%A8%8B">RunLoop 与线程</a></li>
<li><a href="#runloop%E7%9A%84%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91">RunLoop 的运行逻辑</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB">线程保活</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a>
<ul>
<li><a href="#%E5%90%84%E7%A7%8D%E9%98%9F%E5%88%97%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E6%9E%9C">各种队列的执行效果</a></li>
<li><a href="#%E8%AF%B7%E9%97%AE%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">请问下面代码的打印结果是什么？</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5">线程同步</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83">线程同步方案性能比较</a></li>
</ul>
</li>
<li><a href="#timer">Timer</a>
<ul>
<li><a href="#cadisplaylink%E3%80%81nstimer%E3%80%81dispatch-source-t">CADisplayLink、NSTimer、dispatch_source_t</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">内存管理</a>
<ul>
<li><a href="#ios%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">iOS 程序的内存布局</a></li>
<li><a href="#tagged-pointer">Tagged Pointer</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="面向对象"><a class="header" href="#面向对象">面向对象</a></h2>
<h3 id="oc---cc"><a class="header" href="#oc---cc">OC -&gt; C/C++</a></h3>
<pre><code class="language-bash">$ clang -rewrite-objc main.m -o main.cpp
// 指定平台和架构。模拟器(i386)、32bit(armv7)、64bit(arm64)
$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp
// cannot create __weak reference in file using manual reference 解决方法：支持 ARC，指定运行时版本
$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-14.0.0 main.m
</code></pre>
<h3 id="一个-nsobject-对象占用多少内存"><a class="header" href="#一个-nsobject-对象占用多少内存">一个 NSObject 对象占用多少内存？</a></h3>
<ul>
<li>系统分配了 16 个字节给 NSObject 对象（通过 <code>malloc_size</code> 函数获得）</li>
<li>但 NSObject 对象内部只用了 8 个字节的空间（64 位下，可以通过 <code>class_getInstanceSize</code> 函数获得）</li>
</ul>
<pre><code class="language-objectivec">// 获取 NSObjcet 类实例对象的成员变量所占用的空间，其实例对象的成员变量只用 isa，所以返回 8
NSLog(@&quot;%zd&quot;, class_getInstanceSize([NSObjcet class]);
// 获取 obj 指针所指向内存的大小，返回 16
NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)obj));
// 编译时，上方两个方法是运行时
NSLog(@&quot;%zd&quot;, sizeof(obj));
</code></pre>
<ul>
<li>结构体内存对齐：最大成员大小的倍数</li>
<li>iOS 内存对齐：16 的倍数</li>
</ul>
<h3 id="对象的-isa-指针指向哪里"><a class="header" href="#对象的-isa-指针指向哪里">对象的 isa 指针指向哪里？</a></h3>
<ul>
<li>instance 对象的指针指向 class 对象</li>
<li>class 对象的指针指向 meta-class 对象</li>
<li>meta-class 对象的指针指向基类的 meta-class 对象、</li>
</ul>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202160957523.png" alt="" /></p>
<h3 id="oc-的类信息存放在哪里"><a class="header" href="#oc-的类信息存放在哪里">OC 的类信息存放在哪里？</a></h3>
<ul>
<li>对象方法、属性、成员变量、协议信息，存放在 class 对象中</li>
<li>类方法存放在 meta-class 对象中</li>
<li>成员变量的具体值，存放在 instance 对象中</li>
</ul>
<hr />
<h2 id="kvo"><a class="header" href="#kvo">KVO</a></h2>
<h3 id="ios-使用什么方式实现一个对象的-kvokvo-的本质是什么"><a class="header" href="#ios-使用什么方式实现一个对象的-kvokvo-的本质是什么">iOS 使用什么方式实现一个对象的 KVO？（KVO 的本质是什么？）</a></h3>
<ul>
<li>利用 Runtime API 动态生成一个子类（NSKVONotifying_SomeClassName），并且让 instance 对象的 isa 指针指向这个全新的子类</li>
<li>当修改 instance 对象的属性时，会调用 Foundation 的 <code>_NSSet(*: Int、Double、Char 等)ValueAndNotify</code> 函数，这个函数的实现：</li>
</ul>
<blockquote>
<ol>
<li><code>willChangeValueForKey:</code></li>
<li>父类原来的 setter</li>
<li><code>didChangeValueForKey:</code></li>
</ol>
</blockquote>
<p><code>didChangeValueForKey:</code> 内部会调用 observer 的 <code>observerValueForKeyPath:ofObject:change:context</code> 方法</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202160959104.png" alt="" /></p>
<h3 id="如何手动触发-kvo"><a class="header" href="#如何手动触发-kvo">如何手动触发 KVO</a></h3>
<ul>
<li>手动调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code></li>
</ul>
<h3 id="直接修改成员变量的值会触发-kvo-么"><a class="header" href="#直接修改成员变量的值会触发-kvo-么">直接修改成员变量的值会触发 KVO 么？</a></h3>
<ul>
<li>不会</li>
</ul>
<hr />
<h2 id="kvc"><a class="header" href="#kvc">KVC</a></h2>
<h3 id="通过-kvc-修改属性会触发-kvo-么"><a class="header" href="#通过-kvc-修改属性会触发-kvo-么">通过 KVC 修改属性会触发 KVO 么？</a></h3>
<ul>
<li>会</li>
</ul>
<h3 id="setvalueforkey-原理"><a class="header" href="#setvalueforkey-原理"><code>setValue:forKey:</code> 原理</a></h3>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161000082.png" alt="" /></p>
<h3 id="valueforkey-原理"><a class="header" href="#valueforkey-原理"><code>valueForKey:</code> 原理</a></h3>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161001048.png" alt="" /></p>
<hr />
<h2 id="category"><a class="header" href="#category">Category</a></h2>
<h3 id="category-的原理"><a class="header" href="#category-的原理">Category 的原理</a></h3>
<ul>
<li>Category 编译之后的底层结构是 <code>struct category_t</code>，里面存储着分类的对象方法、类方法、属性、协议信息</li>
<li>在程序运行时候，runtime 会将 Category 的数据合并到类信息中（类对象、元类对象中）</li>
</ul>
<h3 id="category-和-class-extension-的区别"><a class="header" href="#category-和-class-extension-的区别">Category 和 Class Extension 的区别</a></h3>
<ul>
<li><strong>Class Extension 是在编译时</strong>，它的数据就已经包含在类信息中</li>
<li><strong>Category 是在运行时</strong>，才会将数据合并到类信息中</li>
</ul>
<h3 id="load-方法"><a class="header" href="#load-方法">+load 方法</a></h3>
<ul>
<li>
<p><code>+load</code> 方法会在 runtime 加载<strong>类、分类</strong>时调用</p>
</li>
<li>
<p>每个<strong>类、分类</strong>的 <code>+load</code> 在程序运行时只调用一次</p>
</li>
<li>
<p>调用顺序</p>
<ol>
<li><strong>先调用类的 +load</strong></li>
</ol>
<ul>
<li><strong>按照编译顺序调用</strong>（先编译先调用）</li>
<li>调用子类的 +load 之前会调用父类的 +load</li>
</ul>
<ol start="2">
<li><strong>再调分类的 +load</strong></li>
</ol>
<ul>
<li>按照编译顺序调用（先编译先调用）</li>
</ul>
</li>
<li>
<p><strong>+load 方法是根据方法地址直接调用，并不是经过 objc_msgSend 函数调用</strong></p>
</li>
</ul>
<h3 id="initialize-方法"><a class="header" href="#initialize-方法">+initialize 方法</a></h3>
<ul>
<li>+initialize 方法会在类第一次收到消息时调用</li>
<li>调用顺序
<ul>
<li>先调用父类的 +initialize，再调用子类的 +initialize （先初始化父类，再初始化子类，每个类只初始化一次）</li>
</ul>
</li>
<li><strong>如果子类没有实现 +initialize，会调用父类的 +initialize （所以父类的 +initialize 可能会被调用多次）</strong></li>
<li><strong>如果分类实现了 +initialize，就覆盖类本身的 +initialize</strong></li>
</ul>
<h3 id="给-category-添加成员变量"><a class="header" href="#给-category-添加成员变量">给 Category 添加成员变量</a></h3>
<ul>
<li>不能直接给 Category 添加成员变量，但可以通过 <strong>关联对象</strong> 间接实现</li>
</ul>
<h4 id="关联对象"><a class="header" href="#关联对象">关联对象</a></h4>
<ul>
<li>添加关联对象</li>
</ul>
<p><code>void objc_setAssociatedObject(id object, const void * key, id value, objc_AssociationPolicy policy)</code></p>
<ul>
<li>获取关联对象</li>
</ul>
<p><code>id objc_getAssociatedObject(id object, const void * key)</code></p>
<ul>
<li>移除所有关联对象</li>
</ul>
<p><code>void objc_removeAssociatedObjects(id object)</code></p>
<h4 id="关联对象的-key-的常见用法"><a class="header" href="#关联对象的-key-的常见用法">关联对象的 key 的常见用法</a></h4>
<pre><code class="language-objectivec">static void *MyKey = &amp;MyKey;
objc_setAssociatedObject(obj, MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)
objc_getAssociatedObject(obj, MyKey)

static char MyKey;
objc_setAssociatedObject(obj, &amp;MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)
objc_getAssociatedObject(obj, &amp;MyKey)

// 使用属性名作为key
objc_setAssociatedObject(obj, @&quot;property&quot;, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
objc_getAssociatedObject(obj, @&quot;property&quot;);

// 使用get方法的@selecor作为key
objc_setAssociatedObject(obj, @selector(getter), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)
objc_getAssociatedObject(obj, @selector(getter))
</code></pre>
<h4 id="objc_associationpolicy"><a class="header" href="#objc_associationpolicy">objc_AssociationPolicy</a></h4>
<table><thead><tr><th>objc_AssociationPolicy</th><th>对应的修饰符</th></tr></thead><tbody>
<tr><td>OBJC_ASSOCIATION_ASSIGN</td><td>assign</td></tr>
<tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td>strong, nonatomic</td></tr>
<tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td>copy, nonatomic</td></tr>
<tr><td>OBJC_ASSOCIATION_RETAIN</td><td>strong, atomic</td></tr>
<tr><td>OBJC_ASSOCIATION_COPY</td><td>copy, atomic</td></tr>
</tbody></table>
<h4 id="关联对象的原理"><a class="header" href="#关联对象的原理">关联对象的原理</a></h4>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161003141.png" alt="" /></p>
<hr />
<h2 id="block"><a class="header" href="#block">Block</a></h2>
<h3 id="block-的本质"><a class="header" href="#block-的本质">Block 的本质</a></h3>
<ul>
<li>block 本质上也是一个 OC 对象</li>
<li>block 是封装了函数调用和函数调用环境的 OC 对象</li>
</ul>
<h3 id="block-的变量捕获机制"><a class="header" href="#block-的变量捕获机制">Block 的变量捕获机制</a></h3>
<table><thead><tr><th>变量类型</th><th style="text-align: center">捕获到 block 内部</th><th>访问方式</th></tr></thead><tbody>
<tr><td>局部变量 auto</td><td style="text-align: center">✅</td><td>值传递</td></tr>
<tr><td>局部变量 static</td><td style="text-align: center">✅</td><td>指针传递</td></tr>
<tr><td>全局变量</td><td style="text-align: center">❌</td><td>直接访问</td></tr>
</tbody></table>
<h3 id="block-类型"><a class="header" href="#block-类型">Block 类型</a></h3>
<table><thead><tr><th style="text-align: center">block 类型</th><th style="text-align: center">环境</th><th style="text-align: center">内存分配</th><th>复制效果</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>__NSGlobalBlock__</code></td><td style="text-align: center">没有访问 auto 变量</td><td style="text-align: center">数据区（.data 区）</td><td>什么也不做</td></tr>
<tr><td style="text-align: center"><code>__NSStackBlock__</code></td><td style="text-align: center">访问了 auto 变量</td><td style="text-align: center">栈</td><td>从栈复制到堆</td></tr>
<tr><td style="text-align: center"><code>__NSMallocBlock__</code></td><td style="text-align: center"><code>__NSStackBlock__</code> 调用了 copy</td><td style="text-align: center">堆</td><td>引用计数增加</td></tr>
</tbody></table>
<blockquote>
<p>程序区（.text 区） —— 低地址<br />
数据区（.data 区）：全局变量<br />
堆：动态分配<br />
栈 —— 高地址</p>
</blockquote>
<h3 id="block-的-copy"><a class="header" href="#block-的-copy">Block 的 copy</a></h3>
<p>在 ARC 环境下，以下情况编译器会自动将栈上的 block 复制到堆上：</p>
<ul>
<li>block 作为返回值时</li>
<li>将 block 赋值给 __strong 指针时</li>
<li>block 作为 Cocoa API 中方法名含有 <code>usingBlock</code> 的方法参数时</li>
<li>block 作为 GCD API 的方法参数时</li>
</ul>
<h3 id="对象类型的-auto-变量"><a class="header" href="#对象类型的-auto-变量">对象类型的 auto 变量</a></h3>
<p>当 block 访问了对象类型的 auto 变量时：</p>
<ul>
<li>如果 block 在栈上，将不会对 auto 变量产生强引用</li>
<li>如果 block 被拷贝到堆上
<ul>
<li>会调用 block 内部的 copy 函数</li>
<li>copy 函数内部会调用 <code>_Block_object_assign</code> 函数</li>
<li><code>_Block_object_assign</code> 函数会根据 auto 变量的修饰符（<code>__strong</code>, <code>__weak</code>, <code>__unsafe_unretained</code>）做出相应的操作，形成强引用或弱引用</li>
</ul>
</li>
<li>如果 block 从堆上移除
<ul>
<li>会调用 block 内部的 dispose 函数</li>
<li>dispose 函数内部会调用 <code>_Block_object_dispose</code> 函数</li>
<li><code>_Block_object_dispose</code> 函数会自动释放引用的 auto 变量（release）</li>
</ul>
</li>
</ul>
<h3 id="__block-修饰符"><a class="header" href="#__block-修饰符">__block 修饰符</a></h3>
<ul>
<li><code>__block</code> 可以解决 block 内部无法修改 auto 变量值的问题</li>
<li><code>__block</code> 不能修饰全局变量、静态变量</li>
<li>编译器会将 <code>__block</code> 修饰的变量包装成一个对象</li>
</ul>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161004760.png" alt="" />
<img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161004077.png" alt="" /></p>
<h3 id="__block-的内存管理"><a class="header" href="#__block-的内存管理">__block 的内存管理</a></h3>
<ul>
<li>当 block 在栈上时，并不会对 __block 变量产生强引用</li>
<li>当 block 被 copy 到堆时
<ul>
<li>会调用 block 内部的 copy 函数</li>
<li>copy 函数内部会调用 <code>_Block_object_assign</code> 函数</li>
<li><code>_Block_object_assign</code> 函数会对 __block 变量形成强引用（retain）</li>
</ul>
</li>
<li>当 block 从堆中移除时
<ul>
<li>会调用 block 内部的 dispose 函数</li>
<li>dispose 函数内部会调用 <code>_Block_object_dispose</code> 函数</li>
<li><code>_Block_object_dispose</code> 函数会自动释放引用的 __block 变量（release）</li>
</ul>
</li>
</ul>
<h3 id="被-__block-修饰的对象类型"><a class="header" href="#被-__block-修饰的对象类型">被 __block 修饰的对象类型</a></h3>
<ul>
<li>当 __block 变量在栈上时，不会对指向的对象产生强引用</li>
<li>当 __block 变量被 copy 到堆时
<ul>
<li>会调用 __block 变量内部的 copy 函数</li>
<li>copy 函数内部会调用 <code>_Block_object_assign</code>  函数</li>
<li><code>_Block_object_assign</code> 函数会根据所指向对象的修饰符（<code>__strong</code>、<code>__weak</code>、<code>__unsafe_unretained</code>）做出相应的操作，形成强引用（retain）或者弱引用（注意：这里仅限于 ARC 时会 retain，MRC 时不会 retain）</li>
</ul>
</li>
<li>如果 __block 变量从堆上移除
<ul>
<li>会调用 __block 变量内部的 dispose 函数</li>
<li>dispose 函数内部会调用 <code>_Block_object_dispose</code> 函数</li>
<li><code>_Block_object_dispose</code> 函数会自动释放指向的对象（release）</li>
</ul>
</li>
</ul>
<hr />
<h2 id="runtime"><a class="header" href="#runtime">Runtime</a></h2>
<h3 id="class-结构"><a class="header" href="#class-结构">Class 结构</a></h3>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161005645.png" alt="" /></p>
<h3 id="方法缓存"><a class="header" href="#方法缓存">方法缓存</a></h3>
<p>Class 内部结构中有个方法缓存（cache_t），用**散列表（哈希表）**来缓存曾经调用过的方法，可以提高方法的查找速度</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161005849.png" alt="" /></p>
<h3 id="oc-消息机制"><a class="header" href="#oc-消息机制">OC 消息机制</a></h3>
<p>OC 中的方法调用，都是转换为 <code>objc_msgSend</code> 函数的调用，<code>objc_msgSend</code> 的执行流程：</p>
<ol>
<li>
<p>消息发送</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161006685.png" alt="" /></p>
</li>
<li>
<p>动态方法解析</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161006903.png" alt="" /></p>
</li>
<li>
<p>消息转发</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161006143.png" alt="" /></p>
</li>
</ol>
<h3 id="super-关键字"><a class="header" href="#super-关键字"><code>super</code> 关键字</a></h3>
<p>super 调用，底层会转换为 <code>objc_msgSendSuper2</code> 函数的调用，接收 2 个参数：</p>
<ol>
<li>struct objc_super2</li>
<li>SEL</li>
</ol>
<pre><code class="language-objectivec">struct objc_super2 {
  id receiver; // 消息接收者
  Class current_class; // receiver 的 Class 对象
}
</code></pre>
<ul>
<li><strong>消息接收着仍然是子类对象</strong></li>
<li><strong>从父类开始查找方法的实现</strong></li>
</ul>
<hr />
<h2 id="runloop"><a class="header" href="#runloop">RunLoop</a></h2>
<h3 id="runloop-本质"><a class="header" href="#runloop-本质">RunLoop 本质</a></h3>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161007756.png" alt="" /></p>
<p><strong>CFRunLoopModeRef</strong></p>
<ul>
<li>CFRunLoopModeRef  代表 RunLoop 的运行模式</li>
<li>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source0/Source1/Timer/Observer</li>
<li>RunLoop 启动时只能选择其中一个 Mode，作为 currentMode</li>
<li><strong>如果需要切换 Mode，只能退出当前 Loop，再重新选择一个 Mode 进入</strong>
<ul>
<li>不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响</li>
</ul>
</li>
<li><strong>如果 Mode 里没有任何 Source0/Source1/Timer/Observer，RunLoop 会立马退出</strong></li>
</ul>
<ol>
<li><strong>Source0</strong></li>
</ol>
<ul>
<li>触摸事件处理</li>
<li><code>performSelector:onThread:</code></li>
</ul>
<ol start="2">
<li><strong>Source1</strong></li>
</ol>
<ul>
<li>基于 Port 的线程间通信</li>
<li>系统事件捕捉</li>
</ul>
<ol start="3">
<li><strong>Timers</strong></li>
</ol>
<ul>
<li>NSTimer</li>
<li><code>performSelector:withObject:afterDelay:</code></li>
</ul>
<ol start="4">
<li><strong>Observers</strong></li>
</ol>
<ul>
<li>用于监听 RunLoop 的状态</li>
<li>UI 刷新（BeforeWaiting）</li>
<li>Autorelease pool（BeforeWaiting）</li>
</ul>
<h3 id="runloop-与线程"><a class="header" href="#runloop-与线程">RunLoop 与线程</a></h3>
<ul>
<li>每条线程都有唯一的一个与之对应的 RunLoop 对象</li>
<li>RunLoop 保存在一个全局的 Dictionary 里，线程作为 key，RunLoop 作为 value</li>
<li>线程刚创建时并没有 RunLoop 对象，<strong>RunLoop 会在第一次获取它时创建</strong></li>
<li>RunLoop 会在线程结束时销毁</li>
<li>主线程的 RunLoop 已经自动获取（创建），<strong>子线程默认没有开启 RunLoop</strong></li>
</ul>
<h3 id="runloop-的运行逻辑"><a class="header" href="#runloop-的运行逻辑">RunLoop 的运行逻辑</a></h3>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161008263.png" alt="" /></p>
<h3 id="线程保活"><a class="header" href="#线程保活">线程保活</a></h3>
<ul>
<li>NSRunLoop 的 <code>run</code> 方法是无法停止的</li>
</ul>
<blockquote>
<p>If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking  <code>runMode:beforeDate:</code>. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</p>
</blockquote>
<hr />
<h2 id="多线程"><a class="header" href="#多线程">多线程</a></h2>
<h3 id="各种队列的执行效果"><a class="header" href="#各种队列的执行效果">各种队列的执行效果</a></h3>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161008460.png" alt="" /></p>
<h3 id="请问下面代码的打印结果是什么"><a class="header" href="#请问下面代码的打印结果是什么">请问下面代码的打印结果是什么？</a></h3>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161008254.png" alt="" /></p>
<ul>
<li>打印结果是：1、3</li>
<li>因为 <code>performSelector:withObject:afterDelay:</code> 的本质是往 Runloop 中添加定时器，而子线程默认没有启动 Runloop</li>
</ul>
<h3 id="线程同步"><a class="header" href="#线程同步">线程同步</a></h3>
<ol>
<li><strong>OSSPinLock</strong></li>
</ol>
<ul>
<li>
<p><code>OSSpinLock</code> 叫做<strong>自旋锁，等待锁的线程会处于忙等（busy-wait）状态</strong>，一直占用着 CPU 资源</p>
</li>
<li>
<p><strong>目前已不再安全，可能会出现优先级反转问题</strong></p>
</li>
<li>
<p>如果等待锁的线程优先级较高，它会一直占用着 CPU 资源，优先级低的线程就无法释放锁</p>
</li>
<li>
<p>需要导入头文件 <code>#import &lt;libkern/OSAtomic.h&gt;</code></p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161009301.png" alt="" /></p>
</li>
</ul>
<ol start="2">
<li><strong>os_unfair_lock</strong></li>
</ol>
<ul>
<li>
<p>互斥锁</p>
</li>
<li>
<p><code>os_unfair_lock</code> 用于取代不安全的 <code>OSSpinLock</code> ，从 iOS 10 开始才支持</p>
</li>
<li>
<p>等待 <code>os_unfair_lock</code> 锁的线程会处于休眠状态，并非忙等</p>
</li>
<li>
<p>需要导入头文件 <code>#import &lt;os/lock.h&gt;</code></p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161009209.png" alt="" /></p>
</li>
</ul>
<ol start="3">
<li><strong>pthread_mutex</strong> </li>
</ol>
<ul>
<li>
<p><code>mutex</code> 叫做”互斥锁”，等待锁的线程会处于休眠状态</p>
</li>
<li>
<p>需要导入头文件 <code>#import &lt;pthread.h&gt;</code></p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161009346.png" alt="" /></p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161009567.png" alt="" /></p>
</li>
<li>
<p><strong>pthread_mutex – 递归锁</strong> </p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161010697.png" alt="" /></p>
</li>
<li>
<p><strong>pthread_mutex – 条件</strong> </p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161010454.png" alt="" /></p>
</li>
</ul>
<ol start="4">
<li><strong>NSLock、NSRecursiveLock</strong> </li>
</ol>
<ul>
<li>
<p><code>NSLock</code> 是对 <code>mutex</code> 普通锁的封装</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161010366.png" alt="" /></p>
</li>
<li>
<p><code>NSRecursiveLock</code> 是对 mutex 递归锁的封装，API 跟 NSLock 基本一致</p>
</li>
</ul>
<ol start="5">
<li><strong>NSCondition</strong> </li>
</ol>
<ul>
<li>
<p><code>NSCondition</code> 是对 mutex 和 cond 的封装</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161011849.png" alt="" /></p>
</li>
</ul>
<ol start="6">
<li><strong>NSConditionLock</strong> </li>
</ol>
<ul>
<li>
<p><code>NSConditionLock</code> 是对 <code>NSCondition</code> 的进一步封装，可以设置具体的条件值</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161011803.png" alt="" /></p>
</li>
</ul>
<ol start="7">
<li><strong>dispatch_semaphore</strong> </li>
</ol>
<ul>
<li>
<p>semaphore 叫做”信号量”</p>
</li>
<li>
<p>信号量的初始值，可以用来控制线程并发访问的最大数量</p>
</li>
<li>
<p>信号量的初始值为 1，代表同时只允许 1 条线程访问资源，保证线程同步</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161011979.png" alt="" /></p>
</li>
</ul>
<ol start="8">
<li><strong>dispatch_queue</strong> </li>
</ol>
<ul>
<li>
<p>直接使用 GCD 的串行队列，也是可以实现线程同步的</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161012258.png" alt="" /></p>
</li>
</ul>
<ol start="9">
<li><strong>@synchronized</strong> </li>
</ol>
<ul>
<li><code>@synchronized</code> 是对 mutex 递归锁的封装</li>
<li>源码查看：objc4 中的 <code>objc-sync.mm</code> 文件</li>
<li><code>@synchronized(obj)</code> 内部会生成 obj 对应的递归锁，然后进行加锁、解锁操作</li>
</ul>
<ol start="10">
<li><strong>pthread_rwlock</strong>  读写锁</li>
</ol>
<ul>
<li>
<p>等待锁的线程会进入休眠</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161012025.png" alt="" /></p>
</li>
</ul>
<ol start="11">
<li><strong>dispatch_barrier_async</strong> </li>
</ol>
<ul>
<li>
<p><strong>这个函数传入的并发队列必须是自己通过 dispatch_queue_cretate 创建的</strong></p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161012194.png" alt="" /></p>
</li>
<li>
<p><strong>iOS 中的读写安全方案 10、11</strong></p>
</li>
</ul>
<h3 id="线程同步方案性能比较"><a class="header" href="#线程同步方案性能比较">线程同步方案性能比较</a></h3>
<ul>
<li>性能从高到低排序</li>
</ul>
<blockquote>
<p>os_unfair_lock<br />
OSSpinLock<br />
dispatch_semaphore<br />
pthread_mutex<br />
dispatch_queue(DISPATCH_QUEUE_SERIAL)<br />
NSLock<br />
NSCondition<br />
pthread_mutex(recursive)<br />
NSRecursiveLock<br />
NSConditionLock<br />
@synchronized</p>
</blockquote>
<hr />
<h2 id="timer"><a class="header" href="#timer">Timer</a></h2>
<h3 id="cadisplaylinknstimerdispatch_source_t"><a class="header" href="#cadisplaylinknstimerdispatch_source_t">CADisplayLink、NSTimer、dispatch_source_t</a></h3>
<ul>
<li>
<p><code>CADisplayLink</code>、<code>NSTimer</code> 会对 target 产生强引用，如果 target 又对它们产生强引用，那么就会引发循环引用，解决方案：</p>
<ol>
<li>使用 block</li>
</ol>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161013253.png" alt="" /></p>
<ol start="2">
<li>使用 NSProxy</li>
</ol>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161013164.png" alt="" /></p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161013391.png" alt="" /></p>
</li>
<li>
<p><code>NSTimer</code> 依赖于 RunLoop，如果 RunLoop 的任务过于繁重，可能会导致 NSTimer 不准时，而 GCD 的定时器会更加准时</p>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161014689.png" alt="" /></p>
</li>
</ul>
<hr />
<h2 id="内存管理"><a class="header" href="#内存管理">内存管理</a></h2>
<h3 id="ios-程序的内存布局"><a class="header" href="#ios-程序的内存布局">iOS 程序的内存布局</a></h3>
<p><img src="https://raw.githubusercontent.com/KiligWYu/Pics/master/202202161014281.png" alt="" /></p>
<h3 id="tagged-pointer"><a class="header" href="#tagged-pointer">Tagged Pointer</a></h3>
<ul>
<li>从 64bit 开始，iOS 引入了 Tagged Pointer 技术，用于优化 NSNumber、NSDate、NSString 等小对象的存储</li>
<li>在没有使用 Tagged Pointer 之前， NSNumber 等对象需要动态分配内存、维护引用计数等，NSNumber 指针存储的是堆中 NSNumber 对象的地址值</li>
<li>使用 Tagged Pointer 之后，NSNumber 指针里面存储的数据变成了：Tag + Data，也就是<strong>将数据直接存储在了指针中</strong></li>
<li>当指针不够存储数据时，才会使用动态分配内存的方式来存储数据</li>
<li><code>objc_msgSend</code> 能识别 Tagged Pointer，比如 NSNumber 的 <code>intValue</code> 方法，直接从指针提取数据，节省了以前的调用开销</li>
<li>如何判断一个指针是否为 Tagged Pointer？
<ul>
<li>iOS 平台，最高有效位是 1（第 64bit）</li>
<li>Mac 平台，最低有效位是 1</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../ProgrammingLanguages/OC/OC.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../Design/Design.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../ProgrammingLanguages/OC/OC.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../Design/Design.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
